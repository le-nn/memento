{
  "README.html": {
    "href": "README.html",
    "title": "Memento | Memento",
    "keywords": "Memento A simple client-side state management container for Blazor/.NET includes redo/undo and ReduxDevTools support. Japanese Link 使い方と紹介 Redux DevToolsについて Basic Concept We provides a Store that allows you to share state between components. All stores are managed by a single provider and can subscribe to state change notifications. Undirectional flow and immutable change of state provides a predictable architecture. In addition, we provide a store that easily implements Redo/Undo by managing in immutable states. For patterns like Flux or MVU Besides simple store pattern, we also provide patterns inspired by MVU patterns such as Flux and Elm. Since you should change the state via the Reducer, you can change the state based on stricter rules and observe the state in detail. ReduxDevTools Redux DevTools is supported. Redux DevTools is a tool for debugging application's state changes. State can be time traveled and history can be viewed in DevTools. See docs for details of usage. DEMO Page https://le-nn.github.io/memento/ If you have ReduxDevTool installed, DevTool will launch automatically. You can do state history and time travel. Documentation https://le-nn.github.io/memento/docs/README.html React or TS/JS bindings Currently, moved to here https://github.com/le-nn/memento-js Features Less boilerplate, less rule and simple usage Immutable state and Unidirectional flow Multiple stores but managed by single provider, so can observe and manage as one state tree Observe detailed status with command patterns and makes it easier to monitor what happened within the application Concepts and Flow Rules State should always be read-only. The UI then uses the new state to render its display. For patterns like Flux Every Reducer that processes in the action will create new state to reflect the old state combined with the changes expected for the action. To change state our app should Dispatch via Reducer in the action method Store Overview This is an C# and Blazor example that implements counter. Simple Store Pattern using Memento.Core; using System.Collections.Immutable; namespace Memento.Sample.Blazor; public record AsyncCounterState { public int Count { get; init; } = 0; public bool IsLoading { get; init; } = false; public int[] Histories { get; init; } = []; } public class AsyncCounterStore() : Store<AsyncCounterState>(() => new()) { public async Task CountUpAsync() { Mutate(state => state with { IsLoading = true, }); await Task.Delay(800); Mutate(state => state with { IsLoading = false, Count = state.Count + 1, Histories = [.. state.Histories, state.Count + 1], }); } } Flux Store Pattern public record AsyncCounterState { public int Count { get; init; } = 0; public bool IsLoading { get; init; } = false; public int[] Histories { get; init; } = []; } public record AsyncCounterCommands : Command { public record Increment : AsyncCounterCommands; public record BeginLoading : AsyncCounterCommands; } public class AsyncCounterStore() : FluxStore<AsyncCounterState, AsyncCounterCommands>(() => new(), Reducer) { static AsyncCounterState Reducer(AsyncCounterState state, AsyncCounterCommands command) { return command switch { AsyncCounterCommands.Increment => state with { Count = state.Count + 1, IsLoading = false, Histories = [.. state.Histories, state.Count + 1], }, AsyncCounterCommands.BeginLoading => state with { IsLoading = true, }, _ => throw new CommandNotHandledException<AsyncCounterCommands>(command), }; } public async Task CountUpAsync() { Dispatch(new AsyncCounterCommands.BeginLoading()); await Task.Delay(800); Dispatch(new AsyncCounterCommands.Increment()); } } Blazor view in Razor @page \"/counter\" @inherits ObserverComponet @inject AsyncCounterStore AsyncCounterStore <PageTitle>Counter</PageTitle> <h1>Async Counter</h1> <p role=\"status\">Current count: @AsyncCounterStore.State.Count</p> <p role=\"status\">Loading: @AsyncCounterStore.State.IsLoading</p> <p role=\"status\" class=\"mb-0\">History</p> <div class=\"d-flex\"> [ @foreach (var item in string.Join(\", \", AsyncCounterStore.State.Histories)) { @item } ] </div> <button class=\"mt-3 btn btn-primary\" @onclick=\"IncrementCount\">Count up</button> @code { async Task IncrementCount() { await AsyncCounterStore.CountUpAsync(); } } License Designed with ♥ by le-nn. Licensed under the MIT License."
  },
  "api/Memento.Blazor.MementoInitializer.html": {
    "href": "api/Memento.Blazor.MementoInitializer.html",
    "title": "Class MementoInitializer | Memento",
    "keywords": "Class MementoInitializer Namespace Memento.Blazor Assembly Memento.Blazor.dll The component for initializing Memento instance. public class MementoInitializer : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender, IDisposable Inheritance object ComponentBase MementoInitializer Implements IComponent IHandleEvent IHandleAfterRender IDisposable Inherited Members ComponentBase.BuildRenderTree(RenderTreeBuilder) ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Initialized [Parameter] public EventCallback Initialized { get; set; } Property Value EventCallback StoreProvider [Inject] public required StoreProvider StoreProvider { get; set; } Property Value StoreProvider Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() OnAfterRenderAsync(bool) Method invoked after each time the component has been rendered interactively and the UI has finished updating (for example, after elements have been added to the browser DOM). Any ElementReference fields will be populated by the time this runs. This method is not invoked during prerendering or server-side rendering, because those processes are not attached to any live browser DOM and are already complete before the DOM is updated. Note that the component does not automatically re-render after the completion of any returned Task, because that would cause an infinite render loop. protected override Task OnAfterRenderAsync(bool firstRender) Parameters firstRender bool Set to true if this is the first time OnAfterRender(bool) has been invoked on this component instance; otherwise false. Returns Task A Task representing any asynchronous operation. Remarks The OnAfterRender(bool) and OnAfterRenderAsync(bool) lifecycle methods are useful for performing interop, or interacting with values received from @ref. Use the firstRender parameter to ensure that initialization work is only performed once."
  },
  "api/Memento.Blazor.ObserverComponent.html": {
    "href": "api/Memento.Blazor.ObserverComponent.html",
    "title": "Class ObserverComponent | Memento",
    "keywords": "Class ObserverComponent Namespace Memento.Blazor Assembly Memento.Blazor.dll The base class for components that observe state changes in a store. Injected stores that implement the IStateObservable<TMessage> interface will all be subscribed to state change events and automatically call StateHasChanged(). public class ObserverComponent : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender, IDisposable Inheritance object ComponentBase ObserverComponent Implements IComponent IHandleEvent IHandleAfterRender IDisposable Inherited Members ComponentBase.BuildRenderTree(RenderTreeBuilder) ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ObserverComponent() Initializes a new instance of the ObserverComponent class. public ObserverComponent() Properties LatencyMs If greater than 0, the feature will not execute state changes more often than this many times per second. Additional notifications will be suppressed, and observers will be notified of the last state when the time window has elapsed to allow another notification. protected ushort LatencyMs { get; set; } Property Value ushort Methods AddDisposable(IDisposable) Adds a disposable object to the list of disposables. protected void AddDisposable(IDisposable disposable) Parameters disposable IDisposable The disposable object to add. AddDisposables(IEnumerable<IDisposable>) Adds a collection of disposable objects to the list of disposables. protected void AddDisposables(IEnumerable<IDisposable> disposables) Parameters disposables IEnumerable<IDisposable> The collection of disposable objects to add. Dispose() Disposes of the component and unsubscribes from any state. public void Dispose() Dispose(bool) Disposes of the component and unsubscribes from any state. protected virtual void Dispose(bool disposing) Parameters disposing bool Indicates whether the component is being disposed. Exceptions NullReferenceException Throws when you forgot to call base.InitializeAsync(). OnAfterRender(bool) Method invoked after each time the component has rendered interactively and the UI has finished updating (for example, after elements have been added to the browser DOM). Any ElementReference fields will be populated by the time this runs. This method is not invoked during prerendering or server-side rendering, because those processes are not attached to any live browser DOM and are already complete before the DOM is updated. protected override void OnAfterRender(bool firstRender) Parameters firstRender bool Set to true if this is the first time OnAfterRender(bool) has been invoked on this component instance; otherwise false. Remarks The OnAfterRender(bool) and OnAfterRenderAsync(bool) lifecycle methods are useful for performing interop, or interacting with values received from @ref. Use the firstRender parameter to ensure that initialization work is only performed once. OnInitialized() Subscribes to state properties. protected override void OnInitialized() Watch<T>(Func<T>, Action<T>, bool) Adds a watcher to observe changes in the specified selector and perform the specified action. protected void Watch<T>(Func<T> selector, Action<T> action, bool once = false) Parameters selector Func<T> The selector function that retrieves the value to observe. action Action<T> The action to perform when the value changes. once bool Indicates whether the action should be performed only once. Type Parameters T The type of the selector."
  },
  "api/Memento.Blazor.StateChangedObserver.html": {
    "href": "api/Memento.Blazor.StateChangedObserver.html",
    "title": "Class StateChangedObserver | Memento",
    "keywords": "Class StateChangedObserver Namespace Memento.Blazor Assembly Memento.Blazor.dll Represents a component observer that subscribes to a collection of observables. public class StateChangedObserver : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender, IDisposable Inheritance object ComponentBase StateChangedObserver Implements IComponent IHandleEvent IHandleAfterRender IDisposable Inherited Members ComponentBase.BuildRenderTree(RenderTreeBuilder) ComponentBase.OnInitialized() ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Observables Gets or sets the collection of observables to subscribe to. [Parameter] public IEnumerable<IObservable<object>> Observables { get; set; } Property Value IEnumerable<IObservable<object>> OnStateHasChanged Gets or sets the event callback to invoke when the state has changed. [Parameter] public EventCallback OnStateHasChanged { get; set; } Property Value EventCallback Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() OnParametersSet() Method invoked when the component has received parameters from its parent in the render tree, and the incoming values have been assigned to properties. protected override void OnParametersSet()"
  },
  "api/Memento.Blazor.StateSubscriber.html": {
    "href": "api/Memento.Blazor.StateSubscriber.html",
    "title": "Class StateSubscriber | Memento",
    "keywords": "Class StateSubscriber Namespace Memento.Blazor Assembly Memento.Blazor.dll A utility class that automatically subscribes to all IStateChangedNotifier properties on a specific object public static class StateSubscriber Inheritance object StateSubscriber Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Subscribe(object, Action<IStateChangedEventArgs>) public static IDisposable Subscribe(object subject, Action<IStateChangedEventArgs> callback) Parameters subject object callback Action<IStateChangedEventArgs> Returns IDisposable"
  },
  "api/Memento.Blazor.StoreConfigExtension.html": {
    "href": "api/Memento.Blazor.StoreConfigExtension.html",
    "title": "Class StoreConfigExtension | Memento",
    "keywords": "Class StoreConfigExtension Namespace Memento.Blazor Assembly Memento.Blazor.dll Extension methods for configuring store-related services. public static class StoreConfigExtension Inheritance object StoreConfigExtension Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddMemento(IServiceCollection, bool) Adds the Memento service to the IServiceCollection. public static IServiceCollection AddMemento(this IServiceCollection services, bool isScoped = true) Parameters services IServiceCollection isScoped bool If true, registers the StoreProvider with a scoped lifetime. Otherwise, registers with a singleton lifetime. Returns IServiceCollection The registered IServiceCollection instance from the IServiceCollection. AddMiddleware<TMiddleware>(IServiceCollection, bool) Adds a custom middleware to the IServiceCollection. public static IServiceCollection AddMiddleware<TMiddleware>(this IServiceCollection collection, bool isScoped = true) where TMiddleware : Middleware Parameters collection IServiceCollection isScoped bool If true, registers the middleware with a scoped lifetime. Otherwise, registers with a singleton lifetime. Returns IServiceCollection The registered IServiceCollection instance from the IServiceCollection. Type Parameters TMiddleware AddMiddleware<TMiddleware>(IServiceCollection, Func<TMiddleware>, bool) Adds a custom middleware to the IServiceCollection. public static IServiceCollection AddMiddleware<TMiddleware>(this IServiceCollection collection, Func<TMiddleware> middlewareSelector, bool isScoped = true) where TMiddleware : Middleware Parameters collection IServiceCollection middlewareSelector Func<TMiddleware> isScoped bool If true, registers the middleware with a scoped lifetime. Otherwise, registers with a singleton lifetime. Returns IServiceCollection The registered IServiceCollection instance from the IServiceCollection. Type Parameters TMiddleware AddStore<TStore>(IServiceCollection, bool) Adds a custom store to the IServiceCollection. public static IServiceCollection AddStore<TStore>(this IServiceCollection collection, bool isScoped = true) where TStore : class, IStore Parameters collection IServiceCollection isScoped bool If true, registers the store with a scoped lifetime. Otherwise, registers with a singleton lifetime. Returns IServiceCollection The registered IServiceCollection instance from the IServiceCollection. Type Parameters TStore GetStoreProvider(IServiceProvider) Gets the StoreProvider from the IServiceProvider public static StoreProvider GetStoreProvider(this IServiceProvider provider) Parameters provider IServiceProvider Returns StoreProvider The StoreProvider instance from the IServiceProvider. ScanAssemblyAndAddStores(IServiceCollection, Assembly, bool) Scans the assembly and adds all stores that implement IStore to the IServiceCollection. public static IServiceCollection ScanAssemblyAndAddStores(this IServiceCollection services, Assembly assembly, bool isScoped = true) Parameters services IServiceCollection assembly Assembly isScoped bool If true, registers the stores with a scoped lifetime. Otherwise, registers with a singleton lifetime. Returns IServiceCollection The registered IServiceCollection instance from the IServiceCollection."
  },
  "api/Memento.Blazor.html": {
    "href": "api/Memento.Blazor.html",
    "title": "Namespace Memento.Blazor | Memento",
    "keywords": "Namespace Memento.Blazor Classes MementoInitializer The component for initializing Memento instance. ObserverComponent The base class for components that observe state changes in a store. Injected stores that implement the IStateObservable<TMessage> interface will all be subscribed to state change events and automatically call StateHasChanged(). StateChangedObserver Represents a component observer that subscribes to a collection of observables. StateSubscriber A utility class that automatically subscribes to all IStateChangedNotifier properties on a specific object StoreConfigExtension Extension methods for configuring store-related services."
  },
  "api/Memento.Core.AbstractMementoStore-2.html": {
    "href": "api/Memento.Core.AbstractMementoStore-2.html",
    "title": "Class AbstractMementoStore<TState, TMessage> | Memento",
    "keywords": "Class AbstractMementoStore<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll public abstract class AbstractMementoStore<TState, TMessage> : AbstractStore<TState, TMessage>, IStateObservable<TMessage>, IStore<TState, TMessage>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, TMessage>>, IDisposable where TState : class where TMessage : class Type Parameters TState TMessage Inheritance object StateObservable<TMessage> AbstractStore<TState, TMessage> AbstractMementoStore<TState, TMessage> Implements IStateObservable<TMessage> IStore<TState, TMessage> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, TMessage>> IDisposable Derived FluxMementoStore<TState, TMessage> MementoStore<TState, TMessage> Inherited Members AbstractStore<TState, TMessage>.Initializer AbstractStore<TState, TMessage>.State AbstractStore<TState, TMessage>.IsInitialized AbstractStore<TState, TMessage>.Provider AbstractStore<TState, TMessage>.ReducerHandle AbstractStore<TState, TMessage>.Dispose() AbstractStore<TState, TMessage>.Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.Subscribe(Action<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.AsStore<TStore>() AbstractStore<TState, TMessage>.GetStateType() AbstractStore<TState, TMessage>.OnInitializedAsync() AbstractStore<TState, TMessage>.OnBeforeDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnAfterDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnDisposed() AbstractStore<TState, TMessage>.AddDisposable(IDisposable) AbstractStore<TState, TMessage>.AddDisposable(IEnumerable<IDisposable>) StateObservable<TMessage>.StateHasChanged(TMessage) StateObservable<TMessage>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<TMessage>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AbstractMementoStore(Func<TState>, HistoryManager, Reducer<TState, TMessage>) protected AbstractMementoStore(Func<TState> initializer, HistoryManager historyManager, Reducer<TState, TMessage> reducer) Parameters initializer Func<TState> historyManager HistoryManager reducer Reducer<TState, TMessage> Properties CanReDo public bool CanReDo { get; } Property Value bool CanUnDo public bool CanUnDo { get; } Property Value bool FutureHistories public IReadOnlyList<IHistoryItem<IMementoStoreContext<TState>>> FutureHistories { get; } Property Value IReadOnlyList<IHistoryItem<IMementoStoreContext<TState>>> PastHistories public IReadOnlyList<IHistoryItem<IMementoStoreContext<TState>>> PastHistories { get; } Property Value IReadOnlyList<IHistoryItem<IMementoStoreContext<TState>>> Present public IHistoryItem<IMementoStoreContext<TState>>? Present { get; } Property Value IHistoryItem<IMementoStoreContext<TState>> Methods CommitAsync(Func<ValueTask>, Func<ValueTask>, string?) public ValueTask CommitAsync(Func<ValueTask> onDo, Func<ValueTask> onUndo, string? name = null) Parameters onDo Func<ValueTask> onUndo Func<ValueTask> name string Returns ValueTask CommitAsync<TPayload>(Func<ValueTask<TPayload>>, Func<MementoStoreContext<TState, TPayload>, ValueTask>, string?) public ValueTask CommitAsync<TPayload>(Func<ValueTask<TPayload>> onDo, Func<MementoStoreContext<TState, TPayload>, ValueTask> onUndo, string? name = null) where TPayload : notnull Parameters onDo Func<ValueTask<TPayload>> onUndo Func<MementoStoreContext<TState, TPayload>, ValueTask> name string Returns ValueTask Type Parameters TPayload OnContextDisposed(IHistoryItem<IMementoStoreContext<TState>>) public virtual void OnContextDisposed(IHistoryItem<IMementoStoreContext<TState>> command) Parameters command IHistoryItem<IMementoStoreContext<TState>> OnContextLoadedAsync(IHistoryItem<IMementoStoreContext<TState>>) public virtual ValueTask OnContextLoadedAsync(IHistoryItem<IMementoStoreContext<TState>> command) Parameters command IHistoryItem<IMementoStoreContext<TState>> Returns ValueTask OnContextSavedAsync(IHistoryItem<IMementoStoreContext<TState>>) public virtual ValueTask OnContextSavedAsync(IHistoryItem<IMementoStoreContext<TState>> command) Parameters command IHistoryItem<IMementoStoreContext<TState>> Returns ValueTask ReDoAsync() public ValueTask ReDoAsync() Returns ValueTask UnDoAsync() public ValueTask UnDoAsync() Returns ValueTask"
  },
  "api/Memento.Core.AbstractStore-2.html": {
    "href": "api/Memento.Core.AbstractStore-2.html",
    "title": "Class AbstractStore<TState, TMessage> | Memento",
    "keywords": "Class AbstractStore<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll Represents an abstract store that maintains state and handles commands. Implements the IStore, IObservable, and IDisposable interfaces. public abstract class AbstractStore<TState, TMessage> : StateObservable<TMessage>, IStateObservable<TMessage>, IStore<TState, TMessage>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, TMessage>>, IDisposable where TState : class where TMessage : notnull Type Parameters TState The type of the state managed by the store. TMessage Represents an abstract store that maintains state and handles commands. Implements the IStore, IObservable, and IDisposable interfaces. Inheritance object StateObservable<TMessage> AbstractStore<TState, TMessage> Implements IStateObservable<TMessage> IStore<TState, TMessage> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, TMessage>> IDisposable Derived AbstractMementoStore<TState, TMessage> FluxStore<TState, TMessage> Store<TState, TMessage> Inherited Members StateObservable<TMessage>.StateHasChanged(TMessage) StateObservable<TMessage>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<TMessage>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the AbstractStore<TState, TMessage> class. Constructors AbstractStore(Func<TState>, Reducer<TState, TMessage>) Represents an abstract store that maintains state and handles commands. Implements the IStore, IObservable, and IDisposable interfaces. protected AbstractStore(Func<TState> initializer, Reducer<TState, TMessage> reducer) Parameters initializer Func<TState> An initializer that creates an initial state. reducer Reducer<TState, TMessage> A reducer that changes a store state. Remarks Initializes a new instance of the AbstractStore<TState, TMessage> class. Exceptions ArgumentNullException Thrown when initializer returns null. Properties Initializer Gets the state initializer for the store. protected Func<TState> Initializer { get; } Property Value Func<TState> Exceptions ArgumentNullException Thrown when initializer returns null. IsInitialized Gets a value indicating whether the store is initialized. public bool IsInitialized { get; } Property Value bool Exceptions ArgumentNullException Thrown when initializer returns null. Provider Gets the store provider instance for the store. public StoreProvider Provider { get; } Property Value StoreProvider Exceptions InvalidDataException Thrown when the store has not been initialized. ReducerHandle Gets the reducer function that takes a state object and a command object and returns a new state object. public Reducer<object, object> ReducerHandle { get; } Property Value Reducer<object, object> Exceptions ArgumentNullException Thrown when initializer returns null. State Gets the current state of the store. public TState State { get; } Property Value TState Exceptions ArgumentNullException Thrown when initializer returns null. Methods AddDisposable(IEnumerable<IDisposable>) Adds a collection of disposable resources to the store. protected void AddDisposable(IEnumerable<IDisposable> disposable) Parameters disposable IEnumerable<IDisposable> The collection of disposable resources to add. Exceptions ArgumentNullException Thrown when initializer returns null. AddDisposable(IDisposable) Adds a disposable resource to the store. protected void AddDisposable(IDisposable disposable) Parameters disposable IDisposable The disposable resource to add. Exceptions ArgumentNullException Thrown when initializer returns null. AsStore<TStore>() Casts the current store to the specified store type. public TStore AsStore<TStore>() where TStore : IStore<TState, TMessage> Returns TStore The current store cast to the specified store type. Type Parameters TStore The store type to cast to. Exceptions InvalidCastException Thrown when the current store cannot be cast to the specified store type. Dispose() Disposes the store and its resources. public void Dispose() Exceptions ArgumentNullException Thrown when initializer returns null. GetStateType() Gets the type of the state managed by the store. public Type GetStateType() Returns Type The type of the state. Exceptions ArgumentNullException Thrown when initializer returns null. OnAfterDispatch(TState, TMessage?) Called before invoke state changed and return value overrides current state. protected virtual TState OnAfterDispatch(TState state, TMessage? command) Parameters state TState The computed state via _reducer. command TMessage The command for mutating the state. Returns TState override state. Exceptions ArgumentNullException Thrown when initializer returns null. OnBeforeDispatch(TState, TMessage?) Called before dispatching a command and can be used to modify the state. protected virtual TState OnBeforeDispatch(TState state, TMessage? command) Parameters state TState The current state. command TMessage The command for mutating the state. Returns TState An overridden state. Exceptions ArgumentNullException Thrown when initializer returns null. OnDisposed() Called when the store is disposed. protected virtual void OnDisposed() Exceptions ArgumentNullException Thrown when initializer returns null. OnInitializedAsync() Called when the store is initialized asynchronously. protected virtual ValueTask OnInitializedAsync() Returns ValueTask A Task representing the initialization process. Exceptions ArgumentNullException Thrown when initializer returns null. Subscribe(Action<IStateChangedEventArgs<TState, TMessage>>) Subscribes to the store with the provided observer. public IDisposable Subscribe(Action<IStateChangedEventArgs<TState, TMessage>> observer) Parameters observer Action<IStateChangedEventArgs<TState, TMessage>> The observer to subscribe to the store. Returns IDisposable An IDisposable instance that can be used to unsubscribe from the store. Exceptions ArgumentNullException Thrown when initializer returns null. Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>>) Subscribes to the store with the provided observer. public IDisposable Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>> observer) Parameters observer IObserver<IStateChangedEventArgs<TState, TMessage>> The observer to subscribe to the store. Returns IDisposable An IDisposable instance that can be used to unsubscribe from the store. Exceptions ArgumentNullException Thrown when initializer returns null."
  },
  "api/Memento.Core.Command.StateHasChanged-2.html": {
    "href": "api/Memento.Core.Command.StateHasChanged-2.html",
    "title": "Class Command.StateHasChanged<TState, TMessage> | Memento",
    "keywords": "Class Command.StateHasChanged<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll Represents a command that indicates a state change has occurred. public record Command.StateHasChanged<TState, TMessage> : Command.StateHasChanged, IEquatable<Command>, IEquatable<Command.StateHasChanged>, IEquatable<Command.StateHasChanged<TState, TMessage>> where TState : notnull where TMessage : notnull Type Parameters TState Represents a command that indicates a state change has occurred. TMessage Represents a command that indicates a state change has occurred. Inheritance object Command Command.StateHasChanged Command.StateHasChanged<TState, TMessage> Implements IEquatable<Command> IEquatable<Command.StateHasChanged> IEquatable<Command.StateHasChanged<TState, TMessage>> Inherited Members Command.StateHasChanged.StateHasChangedType Command.StateHasChanged.StoreType Command.StateHasChanged.Type Command.StateHasChanged.CreateForceReplaced(object) Command.StateHasChanged.CreateRestored(object) Command.GetFullTypeName() Command.Payload object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StateHasChanged(TState, TMessage?, Type?) public StateHasChanged(TState mutateState, TMessage? message = default, Type? storeType = null) Parameters mutateState TState message TMessage storeType Type Properties Message public TMessage? Message { get; } Property Value TMessage State public TState State { get; } Property Value TState Methods CreateForceReplaced(TState) public static Command.StateHasChanged<TState, TMessage> CreateForceReplaced(TState State) Parameters State TState Returns Command.StateHasChanged<TState, TMessage> CreateRestored(TState) public static Command.StateHasChanged<TState, TMessage> CreateRestored(TState State) Parameters State TState Returns Command.StateHasChanged<TState, TMessage>"
  },
  "api/Memento.Core.Command.StateHasChanged.html": {
    "href": "api/Memento.Core.Command.StateHasChanged.html",
    "title": "Class Command.StateHasChanged | Memento",
    "keywords": "Class Command.StateHasChanged Namespace Memento.Core Assembly Memento.Core.dll Represents a command that indicates a state change has occurred. public record Command.StateHasChanged : Command, IEquatable<Command>, IEquatable<Command.StateHasChanged> Inheritance object Command Command.StateHasChanged Implements IEquatable<Command> IEquatable<Command.StateHasChanged> Derived Command.StateHasChanged<TState, TMessage> Inherited Members Command.GetFullTypeName() Command.Payload object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StateHasChanged(object, object?, Type?) public StateHasChanged(object state, object? message = null, Type? storeType = null) Parameters state object message object storeType Type Properties Message public object? Message { get; } Property Value object State public object State { get; } Property Value object StateHasChangedType public StateHasChangedType StateHasChangedType { get; } Property Value StateHasChangedType StoreType [JsonIgnore] public Type? StoreType { get; } Property Value Type Type Gets the type of the command, excluding the assembly name. public override string Type { get; } Property Value string Methods CreateForceReplaced(object) public static Command.StateHasChanged CreateForceReplaced(object State) Parameters State object Returns Command.StateHasChanged CreateRestored(object) public static Command.StateHasChanged CreateRestored(object State) Parameters State object Returns Command.StateHasChanged"
  },
  "api/Memento.Core.Command.html": {
    "href": "api/Memento.Core.Command.html",
    "title": "Class Command | Memento",
    "keywords": "Class Command Namespace Memento.Core Assembly Memento.Core.dll Represents an abstract base class for commands that mutate the state of a store. public record Command : IEquatable<Command> Inheritance object Command Implements IEquatable<Command> Derived Command.StateHasChanged Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Payload Gets the payload properties of the command as a dictionary. public Dictionary<string, object> Payload { get; } Property Value Dictionary<string, object> Type Gets the type of the command, excluding the assembly name. public virtual string Type { get; } Property Value string Methods GetFullTypeName() Gets the full type name of the command. public string? GetFullTypeName() Returns string The full type name as a string."
  },
  "api/Memento.Core.CommandNotHandledException-1.html": {
    "href": "api/Memento.Core.CommandNotHandledException-1.html",
    "title": "Class CommandNotHandledException<TMessage> | Memento",
    "keywords": "Class CommandNotHandledException<TMessage> Namespace Memento.Core Assembly Memento.Core.dll Represents the exception that is thrown when a command is not handled. public class CommandNotHandledException<TMessage> : Exception, ISerializable where TMessage : notnull Type Parameters TMessage Type of message. Inheritance object Exception CommandNotHandledException<TMessage> Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors CommandNotHandledException(TMessage?) Represents the exception that is thrown when a command is not handled. public CommandNotHandledException(TMessage? command) Parameters command TMessage the command. Properties Command public TMessage? Command { get; } Property Value TMessage"
  },
  "api/Memento.Core.Executors.ConcatAsyncOperationExecutor.html": {
    "href": "api/Memento.Core.Executors.ConcatAsyncOperationExecutor.html",
    "title": "Class ConcatAsyncOperationExecutor | Memento",
    "keywords": "Class ConcatAsyncOperationExecutor Namespace Memento.Core.Executors Assembly Memento.Core.dll Provides a feature to wait for the end of asynchronous processing and connect to the next processing. public class ConcatAsyncOperationExecutor Inheritance object ConcatAsyncOperationExecutor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExecuteAsync(Func<Task>) Waits for the end of asynchronous processing and concat to the next processing. public Task ExecuteAsync(Func<Task> operation) Parameters operation Func<Task> The async operation. Returns Task The async operation contains a result of processing. ExecuteAsync<T>(Func<Task<T>>) Waits for the end of asynchronous processing and cancats to the next processing. public Task<T> ExecuteAsync<T>(Func<Task<T>> operation) Parameters operation Func<Task<T>> The async operation. Returns Task<T> The async oparation contains a result of processing. Type Parameters T"
  },
  "api/Memento.Core.Executors.ThrottledExecutor-1.html": {
    "href": "api/Memento.Core.Executors.ThrottledExecutor-1.html",
    "title": "Class ThrottledExecutor<T> | Memento",
    "keywords": "Class ThrottledExecutor<T> Namespace Memento.Core.Executors Assembly Memento.Core.dll public class ThrottledExecutor<T> : IObservable<T> Type Parameters T Inheritance object ThrottledExecutor<T> Implements IObservable<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ThrottledExecutor() public ThrottledExecutor() Properties LatencyMs public ushort LatencyMs { get; set; } Property Value ushort Methods Invoke(T) public void Invoke(T value) Parameters value T Subscribe(Action<T>) public IDisposable Subscribe(Action<T> action) Parameters action Action<T> Returns IDisposable Subscribe(IObserver<T>) Notifies the provider that an observer is to receive notifications. public IDisposable Subscribe(IObserver<T> observer) Parameters observer IObserver<T> The object that is to receive notifications. Returns IDisposable A reference to an interface that allows observers to stop receiving notifications before the provider has finished sending them."
  },
  "api/Memento.Core.Executors.html": {
    "href": "api/Memento.Core.Executors.html",
    "title": "Namespace Memento.Core.Executors | Memento",
    "keywords": "Namespace Memento.Core.Executors Classes ConcatAsyncOperationExecutor Provides a feature to wait for the end of asynchronous processing and connect to the next processing. ThrottledExecutor<T>"
  },
  "api/Memento.Core.FluxMementoStore-2.html": {
    "href": "api/Memento.Core.FluxMementoStore-2.html",
    "title": "Class FluxMementoStore<TState, TMessage> | Memento",
    "keywords": "Class FluxMementoStore<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll Initializes a new instance of the FluxStore class. public abstract class FluxMementoStore<TState, TMessage> : AbstractMementoStore<TState, TMessage>, IStateObservable<TMessage>, IStore<TState, TMessage>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, TMessage>>, IDisposable where TState : class where TMessage : class Type Parameters TState Initializes a new instance of the FluxStore class. TMessage Initializes a new instance of the FluxStore class. Inheritance object StateObservable<TMessage> AbstractStore<TState, TMessage> AbstractMementoStore<TState, TMessage> FluxMementoStore<TState, TMessage> Implements IStateObservable<TMessage> IStore<TState, TMessage> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, TMessage>> IDisposable Inherited Members AbstractMementoStore<TState, TMessage>.CanReDo AbstractMementoStore<TState, TMessage>.CanUnDo AbstractMementoStore<TState, TMessage>.Present AbstractMementoStore<TState, TMessage>.FutureHistories AbstractMementoStore<TState, TMessage>.PastHistories AbstractMementoStore<TState, TMessage>.OnContextSavedAsync(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, TMessage>.OnContextLoadedAsync(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, TMessage>.OnContextDisposed(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, TMessage>.CommitAsync<TPayload>(Func<ValueTask<TPayload>>, Func<MementoStoreContext<TState, TPayload>, ValueTask>, string) AbstractMementoStore<TState, TMessage>.CommitAsync(Func<ValueTask>, Func<ValueTask>, string) AbstractMementoStore<TState, TMessage>.UnDoAsync() AbstractMementoStore<TState, TMessage>.ReDoAsync() AbstractStore<TState, TMessage>.Initializer AbstractStore<TState, TMessage>.State AbstractStore<TState, TMessage>.IsInitialized AbstractStore<TState, TMessage>.Provider AbstractStore<TState, TMessage>.ReducerHandle AbstractStore<TState, TMessage>.Dispose() AbstractStore<TState, TMessage>.Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.Subscribe(Action<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.AsStore<TStore>() AbstractStore<TState, TMessage>.GetStateType() AbstractStore<TState, TMessage>.OnInitializedAsync() AbstractStore<TState, TMessage>.OnBeforeDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnAfterDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnDisposed() AbstractStore<TState, TMessage>.AddDisposable(IDisposable) AbstractStore<TState, TMessage>.AddDisposable(IEnumerable<IDisposable>) StateObservable<TMessage>.StateHasChanged(TMessage) StateObservable<TMessage>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<TMessage>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FluxMementoStore(Func<TState>, HistoryManager, Reducer<TState, TMessage>) Initializes a new instance of the FluxStore class. protected FluxMementoStore(Func<TState> initializer, HistoryManager historyManager, Reducer<TState, TMessage> reducer) Parameters initializer Func<TState> The state initializer for creating the initial state. historyManager HistoryManager The history manager. reducer Reducer<TState, TMessage> The reducer function for applying commands to the state. Methods Dispatch(Func<TState, TMessage>) Dispatches a command to the store using a message loader function, which updates the state accordingly. public void Dispatch(Func<TState, TMessage> messageLoader) Parameters messageLoader Func<TState, TMessage> The function to generate a command based on the current state. Dispatch(TMessage) Dispatches a command to the store, which updates the state accordingly. public void Dispatch(TMessage command) Parameters command TMessage The command to dispatch."
  },
  "api/Memento.Core.FluxStore-2.html": {
    "href": "api/Memento.Core.FluxStore-2.html",
    "title": "Class FluxStore<TState, TMessage> | Memento",
    "keywords": "Class FluxStore<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. Realize state management like Flux or MVU. You should mutate the state via reducer function specified to constructor params. The Reducer function generates a new state from the current state and a command. public class FluxStore<TState, TMessage> : AbstractStore<TState, TMessage>, IStateObservable<TMessage>, IStore<TState, TMessage>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, TMessage>>, IDisposable where TState : class where TMessage : class Type Parameters TState The type of state managed by the store. TMessage Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. Realize state management like Flux or MVU. You should mutate the state via reducer function specified to constructor params. The Reducer function generates a new state from the current state and a command. Inheritance object StateObservable<TMessage> AbstractStore<TState, TMessage> FluxStore<TState, TMessage> Implements IStateObservable<TMessage> IStore<TState, TMessage> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, TMessage>> IDisposable Inherited Members AbstractStore<TState, TMessage>.Initializer AbstractStore<TState, TMessage>.State AbstractStore<TState, TMessage>.IsInitialized AbstractStore<TState, TMessage>.Provider AbstractStore<TState, TMessage>.ReducerHandle AbstractStore<TState, TMessage>.Dispose() AbstractStore<TState, TMessage>.Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.Subscribe(Action<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.AsStore<TStore>() AbstractStore<TState, TMessage>.GetStateType() AbstractStore<TState, TMessage>.OnInitializedAsync() AbstractStore<TState, TMessage>.OnBeforeDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnAfterDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnDisposed() AbstractStore<TState, TMessage>.AddDisposable(IDisposable) AbstractStore<TState, TMessage>.AddDisposable(IEnumerable<IDisposable>) StateObservable<TMessage>.StateHasChanged(TMessage) StateObservable<TMessage>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<TMessage>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FluxStore(Func<TState>, Reducer<TState, TMessage>) Initializes a new instance of the FluxStore class. protected FluxStore(Func<TState> initializer, Reducer<TState, TMessage> reducer) Parameters initializer Func<TState> The state initializer for creating the initial state. reducer Reducer<TState, TMessage> The reducer function for applying commands to the state. Methods Dispatch(Func<TState, TMessage>) Dispatches a command to the store using a message loader function, which updates the state accordingly. public void Dispatch(Func<TState, TMessage> messageLoader) Parameters messageLoader Func<TState, TMessage> The function to generate a command based on the current state. Dispatch(TMessage) Dispatches a command to the store, which updates the state accordingly. public void Dispatch(TMessage command) Parameters command TMessage The command to dispatch."
  },
  "api/Memento.Core.History.HistoryCommandContext-1.html": {
    "href": "api/Memento.Core.History.HistoryCommandContext-1.html",
    "title": "Class HistoryCommandContext<T> | Memento",
    "keywords": "Class HistoryCommandContext<T> Namespace Memento.Core.History Assembly Memento.Core.dll public record HistoryCommandContext<T> : IHistoryCommandItem<T>, IHistoryItem<T>, IDisposable, IEquatable<HistoryCommandContext<T>> where T : notnull Type Parameters T Inheritance object HistoryCommandContext<T> Implements IHistoryCommandItem<T> IHistoryItem<T> IDisposable IEquatable<HistoryCommandContext<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HistoryCommandContext(Func<ValueTask<T>>, Func<T, ValueTask>, string) public HistoryCommandContext(Func<ValueTask<T>> doHandler, Func<T, ValueTask> undoHandler, string name) Parameters doHandler Func<ValueTask<T>> undoHandler Func<T, ValueTask> name string Properties ContextLoaded public Func<IHistoryItem<T?>, ValueTask>? ContextLoaded { get; init; } Property Value Func<IHistoryItem<T>, ValueTask> ContextSaved public Func<IHistoryItem<T?>, ValueTask>? ContextSaved { get; init; } Property Value Func<IHistoryItem<T>, ValueTask> Disposed public Action<IHistoryCommandItem<T?>>? Disposed { get; init; } Property Value Action<IHistoryCommandItem<T>> HistoryState public T HistoryState { get; } Property Value T IsDisposed public bool IsDisposed { get; } Property Value bool Name public string Name { get; } Property Value string Methods CommitAsync() public ValueTask CommitAsync() Returns ValueTask Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() InvokeContextLoadedAsync() public ValueTask InvokeContextLoadedAsync() Returns ValueTask InvokeContextSavedAsync() public ValueTask InvokeContextSavedAsync() Returns ValueTask RestoreAsync() public ValueTask RestoreAsync() Returns ValueTask"
  },
  "api/Memento.Core.History.HistoryManager.html": {
    "href": "api/Memento.Core.History.HistoryManager.html",
    "title": "Class HistoryManager | Memento",
    "keywords": "Class HistoryManager Namespace Memento.Core.History Assembly Memento.Core.dll public class HistoryManager Inheritance object HistoryManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CanReDo public bool CanReDo { get; } Property Value bool CanUnDo public bool CanUnDo { get; } Property Value bool FutureHistories public IReadOnlyCollection<IHistoryItem<object>> FutureHistories { get; } Property Value IReadOnlyCollection<IHistoryItem<object>> MaxHistoryCount public int MaxHistoryCount { get; set; } Property Value int PastHistories public IReadOnlyCollection<IHistoryItem<object>> PastHistories { get; } Property Value IReadOnlyCollection<IHistoryItem<object>> Present public IHistoryItem<object>? Present { get; } Property Value IHistoryItem<object> Methods CommitAsync<T>(IHistoryCommandItem<T>) public ValueTask CommitAsync<T>(IHistoryCommandItem<T> command) where T : class Parameters command IHistoryCommandItem<T> Returns ValueTask Type Parameters T CommitAsync<T>(Func<ValueTask<T>>, Func<T, ValueTask>, string?, Func<IHistoryItem<T?>, ValueTask>?, Func<IHistoryItem<T?>, ValueTask>?, Action<IHistoryItem<T?>>?) public ValueTask CommitAsync<T>(Func<ValueTask<T>> onDo, Func<T, ValueTask> onUnDo, string? name = null, Func<IHistoryItem<T?>, ValueTask>? saved = null, Func<IHistoryItem<T?>, ValueTask>? loaded = null, Action<IHistoryItem<T?>>? onDispose = null) where T : class Parameters onDo Func<ValueTask<T>> onUnDo Func<T, ValueTask> name string saved Func<IHistoryItem<T>, ValueTask> loaded Func<IHistoryItem<T>, ValueTask> onDispose Action<IHistoryItem<T>> Returns ValueTask Type Parameters T ReDoAsync() public ValueTask<bool> ReDoAsync() Returns ValueTask<bool> UnDoAsync() public ValueTask<bool> UnDoAsync() Returns ValueTask<bool>"
  },
  "api/Memento.Core.History.IHistoryCommandItem-1.html": {
    "href": "api/Memento.Core.History.IHistoryCommandItem-1.html",
    "title": "Interface IHistoryCommandItem<T> | Memento",
    "keywords": "Interface IHistoryCommandItem<T> Namespace Memento.Core.History Assembly Memento.Core.dll public interface IHistoryCommandItem<out T> : IHistoryItem<T>, IDisposable Type Parameters T Inherited Members IHistoryItem<T>.Name IHistoryItem<T>.HistoryState IDisposable.Dispose() Methods CommitAsync() ValueTask CommitAsync() Returns ValueTask InvokeContextLoadedAsync() ValueTask InvokeContextLoadedAsync() Returns ValueTask InvokeContextSavedAsync() ValueTask InvokeContextSavedAsync() Returns ValueTask RestoreAsync() ValueTask RestoreAsync() Returns ValueTask"
  },
  "api/Memento.Core.History.IHistoryItem-1.html": {
    "href": "api/Memento.Core.History.IHistoryItem-1.html",
    "title": "Interface IHistoryItem<T> | Memento",
    "keywords": "Interface IHistoryItem<T> Namespace Memento.Core.History Assembly Memento.Core.dll public interface IHistoryItem<out T> Type Parameters T Properties HistoryState T HistoryState { get; } Property Value T Name string Name { get; } Property Value string"
  },
  "api/Memento.Core.History.html": {
    "href": "api/Memento.Core.History.html",
    "title": "Namespace Memento.Core.History | Memento",
    "keywords": "Namespace Memento.Core.History Classes HistoryCommandContext<T> HistoryManager Interfaces IHistoryCommandItem<T> IHistoryItem<T>"
  },
  "api/Memento.Core.IMementoStoreContext-1.html": {
    "href": "api/Memento.Core.IMementoStoreContext-1.html",
    "title": "Interface IMementoStoreContext<TState> | Memento",
    "keywords": "Interface IMementoStoreContext<TState> Namespace Memento.Core Assembly Memento.Core.dll Represents the context of a memento store. public interface IMementoStoreContext<TState> Type Parameters TState The type of the state. Properties Payload Gets the payload. object Payload { get; } Property Value object State Gets the state. TState State { get; } Property Value TState"
  },
  "api/Memento.Core.IStateObservable-1.html": {
    "href": "api/Memento.Core.IStateObservable-1.html",
    "title": "Interface IStateObservable<TMessage> | Memento",
    "keywords": "Interface IStateObservable<TMessage> Namespace Memento.Core Assembly Memento.Core.dll public interface IStateObservable<out TMessage> : IObservable<IStateChangedEventArgs> where TMessage : notnull Type Parameters TMessage Inherited Members IObservable<IStateChangedEventArgs>.Subscribe(IObserver<IStateChangedEventArgs>) Methods StateHasChanged() Notifies observers that the state of the store has changed. void StateHasChanged()"
  },
  "api/Memento.Core.IStore-2.html": {
    "href": "api/Memento.Core.IStore-2.html",
    "title": "Interface IStore<TState, TMessage> | Memento",
    "keywords": "Interface IStore<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll Represents a store interface that maintains state and handles commands. Implements the IObservable and IDisposable interfaces. public interface IStore<TState, TMessage> : IStore, IDisposable, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, TMessage>> where TState : class where TMessage : notnull Type Parameters TState Represents a store interface that maintains state and handles commands. Implements the IObservable and IDisposable interfaces. TMessage Represents a store interface that maintains state and handles commands. Implements the IObservable and IDisposable interfaces. Inherited Members IStore.ReducerHandle IStore.GetStateType() IDisposable.Dispose() IObservable<IStateChangedEventArgs>.Subscribe(IObserver<IStateChangedEventArgs>) IObservable<IStateChangedEventArgs<TState, TMessage>>.Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>>) Properties State Gets the current state of the store. TState State { get; } Property Value TState"
  },
  "api/Memento.Core.IStore.html": {
    "href": "api/Memento.Core.IStore.html",
    "title": "Interface IStore | Memento",
    "keywords": "Interface IStore Namespace Memento.Core Assembly Memento.Core.dll Represents the event arguments for a state change. public interface IStore : IDisposable, IObservable<IStateChangedEventArgs> Inherited Members IDisposable.Dispose() IObservable<IStateChangedEventArgs>.Subscribe(IObserver<IStateChangedEventArgs>) Properties ReducerHandle Gets the reducer function that takes a state object and a command object and returns a new state object. Reducer<object, object> ReducerHandle { get; } Property Value Reducer<object, object> State Gets the current state of the store. object State { get; } Property Value object Methods GetStateType() Gets the type of the state managed by the store. Type GetStateType() Returns Type The Type of the state."
  },
  "api/Memento.Core.MementoStore-1.html": {
    "href": "api/Memento.Core.MementoStore-1.html",
    "title": "Class MementoStore<TState> | Memento",
    "keywords": "Class MementoStore<TState> Namespace Memento.Core Assembly Memento.Core.dll Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. public class MementoStore<TState> : MementoStore<TState, string>, IStateObservable<string>, IStore<TState, string>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, string>>, IDisposable where TState : class Type Parameters TState The type of state managed by the store. Inheritance object StateObservable<string> AbstractStore<TState, string> AbstractMementoStore<TState, string> MementoStore<TState, string> MementoStore<TState> Implements IStateObservable<string> IStore<TState, string> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, string>> IDisposable Inherited Members MementoStore<TState, string>.Mutate(Func<TState, TState>, string) MementoStore<TState, string>.Mutate(TState, string) AbstractMementoStore<TState, string>.CanReDo AbstractMementoStore<TState, string>.CanUnDo AbstractMementoStore<TState, string>.Present AbstractMementoStore<TState, string>.FutureHistories AbstractMementoStore<TState, string>.PastHistories AbstractMementoStore<TState, string>.OnContextSavedAsync(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, string>.OnContextLoadedAsync(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, string>.OnContextDisposed(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, string>.CommitAsync<TPayload>(Func<ValueTask<TPayload>>, Func<MementoStoreContext<TState, TPayload>, ValueTask>, string) AbstractMementoStore<TState, string>.CommitAsync(Func<ValueTask>, Func<ValueTask>, string) AbstractMementoStore<TState, string>.UnDoAsync() AbstractMementoStore<TState, string>.ReDoAsync() AbstractStore<TState, string>.Initializer AbstractStore<TState, string>.State AbstractStore<TState, string>.IsInitialized AbstractStore<TState, string>.Provider AbstractStore<TState, string>.ReducerHandle AbstractStore<TState, string>.Dispose() AbstractStore<TState, string>.Subscribe(IObserver<IStateChangedEventArgs<TState, string>>) AbstractStore<TState, string>.Subscribe(Action<IStateChangedEventArgs<TState, string>>) AbstractStore<TState, string>.AsStore<TStore>() AbstractStore<TState, string>.GetStateType() AbstractStore<TState, string>.OnInitializedAsync() AbstractStore<TState, string>.OnBeforeDispatch(TState, string) AbstractStore<TState, string>.OnAfterDispatch(TState, string) AbstractStore<TState, string>.OnDisposed() AbstractStore<TState, string>.AddDisposable(IDisposable) AbstractStore<TState, string>.AddDisposable(IEnumerable<IDisposable>) StateObservable<string>.StateHasChanged(string) StateObservable<string>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<string>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MementoStore(Func<TState>, HistoryManager) Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. public MementoStore(Func<TState> initializer, HistoryManager historyManager) Parameters initializer Func<TState> historyManager HistoryManager"
  },
  "api/Memento.Core.MementoStore-2.html": {
    "href": "api/Memento.Core.MementoStore-2.html",
    "title": "Class MementoStore<TState, TMessage> | Memento",
    "keywords": "Class MementoStore<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll public abstract class MementoStore<TState, TMessage> : AbstractMementoStore<TState, TMessage>, IStateObservable<TMessage>, IStore<TState, TMessage>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, TMessage>>, IDisposable where TState : class where TMessage : class Type Parameters TState TMessage Inheritance object StateObservable<TMessage> AbstractStore<TState, TMessage> AbstractMementoStore<TState, TMessage> MementoStore<TState, TMessage> Implements IStateObservable<TMessage> IStore<TState, TMessage> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, TMessage>> IDisposable Derived MementoStore<TState> Inherited Members AbstractMementoStore<TState, TMessage>.CanReDo AbstractMementoStore<TState, TMessage>.CanUnDo AbstractMementoStore<TState, TMessage>.Present AbstractMementoStore<TState, TMessage>.FutureHistories AbstractMementoStore<TState, TMessage>.PastHistories AbstractMementoStore<TState, TMessage>.OnContextSavedAsync(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, TMessage>.OnContextLoadedAsync(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, TMessage>.OnContextDisposed(IHistoryItem<IMementoStoreContext<TState>>) AbstractMementoStore<TState, TMessage>.CommitAsync<TPayload>(Func<ValueTask<TPayload>>, Func<MementoStoreContext<TState, TPayload>, ValueTask>, string) AbstractMementoStore<TState, TMessage>.CommitAsync(Func<ValueTask>, Func<ValueTask>, string) AbstractMementoStore<TState, TMessage>.UnDoAsync() AbstractMementoStore<TState, TMessage>.ReDoAsync() AbstractStore<TState, TMessage>.Initializer AbstractStore<TState, TMessage>.State AbstractStore<TState, TMessage>.IsInitialized AbstractStore<TState, TMessage>.Provider AbstractStore<TState, TMessage>.ReducerHandle AbstractStore<TState, TMessage>.Dispose() AbstractStore<TState, TMessage>.Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.Subscribe(Action<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.AsStore<TStore>() AbstractStore<TState, TMessage>.GetStateType() AbstractStore<TState, TMessage>.OnInitializedAsync() AbstractStore<TState, TMessage>.OnBeforeDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnAfterDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnDisposed() AbstractStore<TState, TMessage>.AddDisposable(IDisposable) AbstractStore<TState, TMessage>.AddDisposable(IEnumerable<IDisposable>) StateObservable<TMessage>.StateHasChanged(TMessage) StateObservable<TMessage>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<TMessage>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MementoStore(Func<TState>, HistoryManager) protected MementoStore(Func<TState> initializer, HistoryManager historyManager) Parameters initializer Func<TState> historyManager HistoryManager Methods Mutate(Func<TState, TState>, TMessage?) Mutates the state using a reducer function. public void Mutate(Func<TState, TState> reducer, TMessage? message = null) Parameters reducer Func<TState, TState> The reducer function to apply. message TMessage The message that describes what state change has occurred. Mutate(TState, TMessage?) Mutates the state using a new state. public void Mutate(TState state, TMessage? command = null) Parameters state TState The new state to apply. command TMessage"
  },
  "api/Memento.Core.MementoStoreContext-2.html": {
    "href": "api/Memento.Core.MementoStoreContext-2.html",
    "title": "Class MementoStoreContext<TState, TPayload> | Memento",
    "keywords": "Class MementoStoreContext<TState, TPayload> Namespace Memento.Core Assembly Memento.Core.dll Represents the context of a memento store with payload. public record MementoStoreContext<TState, TPayload> : IMementoStoreContext<TState>, IEquatable<MementoStoreContext<TState, TPayload>> where TPayload : notnull Type Parameters TState The type of the state. TPayload The type of the payload. Inheritance object MementoStoreContext<TState, TPayload> Implements IMementoStoreContext<TState> IEquatable<MementoStoreContext<TState, TPayload>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MementoStoreContext(TState, TPayload) Initializes a new instance of the MementoStoreContext<TState, TPayload> class. public MementoStoreContext(TState state, TPayload payload) Parameters state TState The state. payload TPayload The payload. Properties Payload Gets the payload. public TPayload Payload { get; } Property Value TPayload State Gets the state. public TState State { get; } Property Value TState"
  },
  "api/Memento.Core.Middleware.html": {
    "href": "api/Memento.Core.Middleware.html",
    "title": "Class Middleware | Memento",
    "keywords": "Class Middleware Namespace Memento.Core Assembly Memento.Core.dll public abstract class Middleware : IDisposable Inheritance object Middleware Implements IDisposable Derived BrowserReduxDevToolMiddleware ReduxDevToolMiddleware RemoteReduxDevToolMiddleware Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Handler Gets the handler for this middleware. public MiddlewareHandler Handler { get; } Property Value MiddlewareHandler Methods Create(IServiceProvider) Creates the handler for this middleware. protected abstract MiddlewareHandler Create(IServiceProvider provider) Parameters provider IServiceProvider The service provider. Returns MiddlewareHandler The created middleware handler. Dispose() Disposes the middleware. public void Dispose()"
  },
  "api/Memento.Core.MiddlewareHandler.html": {
    "href": "api/Memento.Core.MiddlewareHandler.html",
    "title": "Class MiddlewareHandler | Memento",
    "keywords": "Class MiddlewareHandler Namespace Memento.Core Assembly Memento.Core.dll Represents an abstract class for middleware handlers. public abstract class MiddlewareHandler : IDisposable Inheritance object MiddlewareHandler Implements IDisposable Derived ReduxDevToolMiddlewareHandler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public virtual void Dispose() HandleProviderDispatch(RootState?, IStateChangedEventArgs, NextProviderMiddlewareCallback) Handles the provider dispatch. public virtual RootState? HandleProviderDispatch(RootState? state, IStateChangedEventArgs e, NextProviderMiddlewareCallback next) Parameters state RootState The current state. e IStateChangedEventArgs The event arguments. next NextProviderMiddlewareCallback The next middleware callback. Returns RootState The result of the next middleware callback. HandleStoreDispatch(object?, object?, NextStoreMiddlewareCallback) Handles the store dispatch. public virtual object? HandleStoreDispatch(object? state, object? command, NextStoreMiddlewareCallback next) Parameters state object The current state. command object The command being dispatched. next NextStoreMiddlewareCallback The next middleware callback. Returns object The result of the next middleware callback. InitializedAsync() Called when the store is initialized. protected virtual Task InitializedAsync() Returns Task A task representing the asynchronous operation. OnInitializedAsync() Called when the store is initialized. protected virtual Task OnInitializedAsync() Returns Task A task representing the asynchronous operation."
  },
  "api/Memento.Core.NextProviderMiddlewareCallback.html": {
    "href": "api/Memento.Core.NextProviderMiddlewareCallback.html",
    "title": "Delegate NextProviderMiddlewareCallback | Memento",
    "keywords": "Delegate NextProviderMiddlewareCallback Namespace Memento.Core Assembly Memento.Core.dll Represents a delegate for the next provider middleware callback. public delegate RootState NextProviderMiddlewareCallback(RootState? state, IStateChangedEventArgs e) Parameters state RootState The current state. e IStateChangedEventArgs The event arguments. Returns RootState The result of the next middleware callback."
  },
  "api/Memento.Core.NextStoreMiddlewareCallback.html": {
    "href": "api/Memento.Core.NextStoreMiddlewareCallback.html",
    "title": "Delegate NextStoreMiddlewareCallback | Memento",
    "keywords": "Delegate NextStoreMiddlewareCallback Namespace Memento.Core Assembly Memento.Core.dll Represents a delegate for the next store middleware callback. public delegate object NextStoreMiddlewareCallback(object? state, object? command) Parameters state object The current state. command object The command being dispatched. Returns object The result of the next middleware callback."
  },
  "api/Memento.Core.Reducer-2.html": {
    "href": "api/Memento.Core.Reducer-2.html",
    "title": "Delegate Reducer<TState, TMessage> | Memento",
    "keywords": "Delegate Reducer<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll Represents a delegate that defines a reducer function. public delegate TState Reducer<TState, TMessage>(TState state, TMessage? command) where TState : class where TMessage : notnull Parameters state TState The current state. command TMessage The message/command to be processed. Returns TState The updated state. Type Parameters TState The type of the state. TMessage The type of the message."
  },
  "api/Memento.Core.RootState.html": {
    "href": "api/Memento.Core.RootState.html",
    "title": "Class RootState | Memento",
    "keywords": "Class RootState Namespace Memento.Core Assembly Memento.Core.dll Represents the root state of the application. public record RootState : IReadOnlyDictionary<string, object?>, IReadOnlyCollection<KeyValuePair<string, object?>>, IEnumerable<KeyValuePair<string, object?>>, IEnumerable, IEquatable<RootState> Inheritance object RootState Implements IReadOnlyDictionary<string, object> IReadOnlyCollection<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>> IEnumerable IEquatable<RootState> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Count Gets the number of elements in the collection. public int Count { get; } Property Value int The number of elements in the collection. this[string] Gets the element that has the specified key in the read-only dictionary. public object? this[string key] { get; } Parameters key string The key to locate. Property Value object The element that has the specified key in the read-only dictionary. Exceptions ArgumentNullException key is null. KeyNotFoundException The property is retrieved and key is not found. Keys Gets an enumerable collection that contains the keys in the read-only dictionary. public IEnumerable<string> Keys { get; } Property Value IEnumerable<string> An enumerable collection that contains the keys in the read-only dictionary. Values Gets an enumerable collection that contains the values in the read-only dictionary. public IEnumerable<object> Values { get; } Property Value IEnumerable<object> An enumerable collection that contains the values in the read-only dictionary. Methods AsDictionary() Gets the root state as a dictionary. public Dictionary<string, object> AsDictionary() Returns Dictionary<string, object> The root state as a dictionary. ContainsKey(string) Determines whether the read-only dictionary contains an element that has the specified key. public bool ContainsKey(string key) Parameters key string The key to locate. Returns bool true if the read-only dictionary contains an element that has the specified key; otherwise, false. Exceptions ArgumentNullException key is null. GetEnumerator() Returns an enumerator that iterates through the collection. public IEnumerator<KeyValuePair<string, object?>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, object>> An enumerator that can be used to iterate through the collection. GetState<TState>(string) Gets the state of the specified type with the specified key. public TState? GetState<TState>(string key) Parameters key string The key. Returns TState The state of the specified type with the specified key. Type Parameters TState The type of the state. ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. TryGetValue(string, out object) Gets the value that is associated with the specified key. public bool TryGetValue(string key, out object value) Parameters key string The key to locate. value object When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized. Returns bool true if the object that implements the IReadOnlyDictionary<TKey, TValue> interface contains an element that has the specified key; otherwise, false. Exceptions ArgumentNullException key is null."
  },
  "api/Memento.Core.RootStateChangedEventArgs.html": {
    "href": "api/Memento.Core.RootStateChangedEventArgs.html",
    "title": "Class RootStateChangedEventArgs | Memento",
    "keywords": "Class RootStateChangedEventArgs Namespace Memento.Core Assembly Memento.Core.dll Represents the event arguments for a root state change. public record RootStateChangedEventArgs : IEquatable<RootStateChangedEventArgs> Inheritance object RootStateChangedEventArgs Implements IEquatable<RootStateChangedEventArgs> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties RootState Gets or sets the root state. public required RootState RootState { get; init; } Property Value RootState StateChangedEvent Gets or sets the state changed event. public required IStateChangedEventArgs StateChangedEvent { get; init; } Property Value IStateChangedEventArgs Store Gets or sets the store. public required IStore Store { get; init; } Property Value IStore"
  },
  "api/Memento.Core.ServiceProviderExtensions.html": {
    "href": "api/Memento.Core.ServiceProviderExtensions.html",
    "title": "Class ServiceProviderExtensions | Memento",
    "keywords": "Class ServiceProviderExtensions Namespace Memento.Core Assembly Memento.Core.dll public static class ServiceProviderExtensions Inheritance object ServiceProviderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetAllMiddleware(IServiceProvider) Retrieves all instances of Middleware from the specified provider. public static IEnumerable<Middleware> GetAllMiddleware(this IServiceProvider provider) Parameters provider IServiceProvider The service provider. Returns IEnumerable<Middleware> An enumerable collection of Middleware instances. GetAllStores(IServiceProvider) Retrieves all instances of IStore<TState, TMessage> from the specified provider. public static IEnumerable<IStore> GetAllStores(this IServiceProvider provider) Parameters provider IServiceProvider The service provider. Returns IEnumerable<IStore> An enumerable collection of IStore<TState, TMessage> instances. GetServices<T>(IServiceProvider) Retrieves all instances of the specified type T from the specified provider. public static IEnumerable<T> GetServices<T>(this IServiceProvider provider) Parameters provider IServiceProvider The service provider. Returns IEnumerable<T> An enumerable collection of instances of type T. Type Parameters T The type of the instances to retrieve. Exceptions InvalidOperationException Thrown when the service cannot be resolved."
  },
  "api/Memento.Core.StateHasChangedType.html": {
    "href": "api/Memento.Core.StateHasChangedType.html",
    "title": "Enum StateHasChangedType | Memento",
    "keywords": "Enum StateHasChangedType Namespace Memento.Core Assembly Memento.Core.dll public enum StateHasChangedType Fields ForceReplaced = 1 Restored = 2 StateHasChanged = 0"
  },
  "api/Memento.Core.StateObservable-1.html": {
    "href": "api/Memento.Core.StateObservable-1.html",
    "title": "Class StateObservable<TMessage> | Memento",
    "keywords": "Class StateObservable<TMessage> Namespace Memento.Core Assembly Memento.Core.dll public abstract class StateObservable<TMessage> : IStateObservable<TMessage>, IObservable<IStateChangedEventArgs> where TMessage : notnull Type Parameters TMessage Inheritance object StateObservable<TMessage> Implements IStateObservable<TMessage> IObservable<IStateChangedEventArgs> Derived AbstractStore<TState, TMessage> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods StateHasChanged(TMessage?) Notifies observers that the state of the store has changed. public void StateHasChanged(TMessage? message = default) Parameters message TMessage The optional message associated with the state change. Subscribe(Action<IStateChangedEventArgs>) Subscribes an action as an observer to receive state change notifications. public IDisposable Subscribe(Action<IStateChangedEventArgs> observer) Parameters observer Action<IStateChangedEventArgs> The action to subscribe as an observer. Returns IDisposable An IDisposable object that can be used to unsubscribe the observer. Subscribe(IObserver<IStateChangedEventArgs>) Subscribes an observer to receive state change notifications. public IDisposable Subscribe(IObserver<IStateChangedEventArgs> observer) Parameters observer IObserver<IStateChangedEventArgs> The observer to subscribe. Returns IDisposable An IDisposable object that can be used to unsubscribe the observer."
  },
  "api/Memento.Core.Store-1.html": {
    "href": "api/Memento.Core.Store-1.html",
    "title": "Class Store<TState> | Memento",
    "keywords": "Class Store<TState> Namespace Memento.Core Assembly Memento.Core.dll Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. public class Store<TState> : Store<TState, string>, IStateObservable<string>, IStore<TState, string>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, string>>, IDisposable where TState : class Type Parameters TState The type of state managed by the store. Inheritance object StateObservable<string> AbstractStore<TState, string> Store<TState, string> Store<TState> Implements IStateObservable<string> IStore<TState, string> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, string>> IDisposable Inherited Members Store<TState, string>.Mutate(Func<TState, TState>, string) Store<TState, string>.Mutate(TState, string) AbstractStore<TState, string>.Initializer AbstractStore<TState, string>.State AbstractStore<TState, string>.IsInitialized AbstractStore<TState, string>.Provider AbstractStore<TState, string>.ReducerHandle AbstractStore<TState, string>.Dispose() AbstractStore<TState, string>.Subscribe(IObserver<IStateChangedEventArgs<TState, string>>) AbstractStore<TState, string>.Subscribe(Action<IStateChangedEventArgs<TState, string>>) AbstractStore<TState, string>.AsStore<TStore>() AbstractStore<TState, string>.GetStateType() AbstractStore<TState, string>.OnInitializedAsync() AbstractStore<TState, string>.OnBeforeDispatch(TState, string) AbstractStore<TState, string>.OnAfterDispatch(TState, string) AbstractStore<TState, string>.OnDisposed() AbstractStore<TState, string>.AddDisposable(IDisposable) AbstractStore<TState, string>.AddDisposable(IEnumerable<IDisposable>) StateObservable<string>.StateHasChanged(string) StateObservable<string>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<string>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Store(Func<TState>) Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. public Store(Func<TState> initializer) Parameters initializer Func<TState> Store(TState) Initializes a new instance of the Store class with the specified initial state. public Store(TState state) Parameters state TState The initial state."
  },
  "api/Memento.Core.Store-2.html": {
    "href": "api/Memento.Core.Store-2.html",
    "title": "Class Store<TState, TMessage> | Memento",
    "keywords": "Class Store<TState, TMessage> Namespace Memento.Core Assembly Memento.Core.dll Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. public class Store<TState, TMessage> : AbstractStore<TState, TMessage>, IStateObservable<TMessage>, IStore<TState, TMessage>, IStore, IObservable<IStateChangedEventArgs>, IObservable<IStateChangedEventArgs<TState, TMessage>>, IDisposable where TState : class where TMessage : notnull Type Parameters TState The type of state managed by the store. TMessage The type of message that describes what state change has occurred. Inheritance object StateObservable<TMessage> AbstractStore<TState, TMessage> Store<TState, TMessage> Implements IStateObservable<TMessage> IStore<TState, TMessage> IStore IObservable<IStateChangedEventArgs> IObservable<IStateChangedEventArgs<TState, TMessage>> IDisposable Derived Store<TState> Inherited Members AbstractStore<TState, TMessage>.Initializer AbstractStore<TState, TMessage>.State AbstractStore<TState, TMessage>.IsInitialized AbstractStore<TState, TMessage>.Provider AbstractStore<TState, TMessage>.ReducerHandle AbstractStore<TState, TMessage>.Dispose() AbstractStore<TState, TMessage>.Subscribe(IObserver<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.Subscribe(Action<IStateChangedEventArgs<TState, TMessage>>) AbstractStore<TState, TMessage>.AsStore<TStore>() AbstractStore<TState, TMessage>.GetStateType() AbstractStore<TState, TMessage>.OnInitializedAsync() AbstractStore<TState, TMessage>.OnBeforeDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnAfterDispatch(TState, TMessage) AbstractStore<TState, TMessage>.OnDisposed() AbstractStore<TState, TMessage>.AddDisposable(IDisposable) AbstractStore<TState, TMessage>.AddDisposable(IEnumerable<IDisposable>) StateObservable<TMessage>.StateHasChanged(TMessage) StateObservable<TMessage>.Subscribe(IObserver<IStateChangedEventArgs>) StateObservable<TMessage>.Subscribe(Action<IStateChangedEventArgs>) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the Store class. Constructors Store(Func<TState>) Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. public Store(Func<TState> initializer) Parameters initializer Func<TState> The state initializer for creating the initial state. Remarks Initializes a new instance of the Store class. Store(TState) Initializes a new instance of the Store class with the specified initial state. public Store(TState state) Parameters state TState The initial state. Methods Mutate(Func<TState, TState>, TMessage?) Mutates the state using a reducer function. public void Mutate(Func<TState, TState> reducer, TMessage? message = default) Parameters reducer Func<TState, TState> The reducer function to apply. message TMessage The message that describes what state change has occurred. Mutate(TState, TMessage?) Mutates the state using a new state. public void Mutate(TState state, TMessage? command = default) Parameters state TState The new state to apply. command TMessage"
  },
  "api/Memento.Core.StoreProvider.html": {
    "href": "api/Memento.Core.StoreProvider.html",
    "title": "Class StoreProvider | Memento",
    "keywords": "Class StoreProvider Namespace Memento.Core Assembly Memento.Core.dll Represents a provider that manages all stores and middlewares. The root state tree is provided from this class. Implements the IObservable and IDisposable interfaces. public class StoreProvider : IObservable<RootStateChangedEventArgs>, IDisposable Inheritance object StoreProvider Implements IObservable<RootStateChangedEventArgs> IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StoreProvider(IServiceProvider, IReadOnlyCollection<IStore>?, IReadOnlyCollection<Middleware>?) Initializes a new instance of the StoreProvider class. public StoreProvider(IServiceProvider container, IReadOnlyCollection<IStore>? stores = null, IReadOnlyCollection<Middleware>? middlewares = null) Parameters container IServiceProvider The service container used to resolve stores and middleware. stores IReadOnlyCollection<IStore> The stores. middlewares IReadOnlyCollection<Middleware> The middlewares. Properties HasDisposed public bool HasDisposed { get; } Property Value bool IsInitialized Gets a value indicating whether the provider has initialized. public bool IsInitialized { get; } Property Value bool Methods CaptureRootState() Captures the current root state of all stores. public RootState CaptureRootState() Returns RootState A RootState instance representing the current state of all stores. CaptureStoreBag() Captures a dictionary containing all stores keyed by their type name. public Dictionary<string, IStore> CaptureStoreBag() Returns Dictionary<string, IStore> A dictionary containing all stores keyed by their type name. Dispose() Disposes the store provider and its resources. public void Dispose() GetAllMiddleware() Gets all middleware registered in the provider. public IEnumerable<Middleware> GetAllMiddleware() Returns IEnumerable<Middleware> An IEnumerable containing all registered middleware. InitializeAsync() Initializes a provider. You must invoke once. public Task InitializeAsync() Returns Task Exceptions InvalidDataException Throws when registered middleware and stores are incorrect. ResolveAllStores() Resolves all stores registered in the provider. public IEnumerable<IStore> ResolveAllStores() Returns IEnumerable<IStore> An IEnumerable containing all registered stores. ResolveStore<TStore>() Resolves a store of the specified type. public TStore ResolveStore<TStore>() where TStore : IStore Returns TStore An instance of the specified store type. Type Parameters TStore The type of the store to resolve. Exceptions ArgumentException Thrown when the specified store type is not registered in the provider. Subscribe(Action<RootStateChangedEventArgs>) Subscribes an action to the store provider. public IDisposable Subscribe(Action<RootStateChangedEventArgs> observer) Parameters observer Action<RootStateChangedEventArgs> The action to subscribe to the store provider. Returns IDisposable An IDisposable instance that can be used to unsubscribe from the store provider. Subscribe(IObserver<RootStateChangedEventArgs>) Subscribes the provided observer to the store provider. public IDisposable Subscribe(IObserver<RootStateChangedEventArgs> observer) Parameters observer IObserver<RootStateChangedEventArgs> The observer to subscribe to the store provider. Returns IDisposable An IDisposable instance that can be used to unsubscribe from the store provider."
  },
  "api/Memento.Core.html": {
    "href": "api/Memento.Core.html",
    "title": "Namespace Memento.Core | Memento",
    "keywords": "Namespace Memento.Core Classes AbstractMementoStore<TState, TMessage> AbstractStore<TState, TMessage> Represents an abstract store that maintains state and handles commands. Implements the IStore, IObservable, and IDisposable interfaces. Command Represents an abstract base class for commands that mutate the state of a store. Command.StateHasChanged Represents a command that indicates a state change has occurred. Command.StateHasChanged<TState, TMessage> Represents a command that indicates a state change has occurred. CommandNotHandledException<TMessage> Represents the exception that is thrown when a command is not handled. FluxMementoStore<TState, TMessage> Initializes a new instance of the FluxStore class. FluxStore<TState, TMessage> Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. Realize state management like Flux or MVU. You should mutate the state via reducer function specified to constructor params. The Reducer function generates a new state from the current state and a command. MementoStoreContext<TState, TPayload> Represents the context of a memento store with payload. MementoStore<TState> Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. MementoStore<TState, TMessage> Middleware MiddlewareHandler Represents an abstract class for middleware handlers. RootState Represents the root state of the application. RootStateChangedEventArgs Represents the event arguments for a root state change. ServiceProviderExtensions StateObservable<TMessage> StoreProvider Represents a provider that manages all stores and middlewares. The root state tree is provided from this class. Implements the IObservable and IDisposable interfaces. Store<TState> Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. Store<TState, TMessage> Represents a store for managing state of type TState. You can observe the state by subscribing to the StateChanged event. Interfaces IMementoStoreContext<TState> Represents the context of a memento store. IStateObservable<TMessage> IStore Represents the event arguments for a state change. IStore<TState, TMessage> Represents a store interface that maintains state and handles commands. Implements the IObservable and IDisposable interfaces. Enums StateHasChangedType Delegates NextProviderMiddlewareCallback Represents a delegate for the next provider middleware callback. NextStoreMiddlewareCallback Represents a delegate for the next store middleware callback. Reducer<TState, TMessage> Represents a delegate that defines a reducer function."
  },
  "api/Memento.ReduxDevTool.ActionItem.html": {
    "href": "api/Memento.ReduxDevTool.ActionItem.html",
    "title": "Class ActionItem | Memento",
    "keywords": "Class ActionItem Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll public record ActionItem : IEquatable<ActionItem> Inheritance object ActionItem Implements IEquatable<ActionItem> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActionItem(string?, object?, string?, string) public ActionItem(string? Type, object? Payload, string? DeclaredType, string StoreName) Parameters Type string Payload object DeclaredType string StoreName string Properties DeclaredType [JsonPropertyName(\"declaredType\")] public string? DeclaredType { get; init; } Property Value string Payload [JsonPropertyName(\"payload\")] public object? Payload { get; init; } Property Value object StoreName [JsonPropertyName(\"storeName\")] public string StoreName { get; init; } Property Value string Type [JsonPropertyName(\"type\")] public string? Type { get; init; } Property Value string"
  },
  "api/Memento.ReduxDevTool.ActionItemFromDevtool.html": {
    "href": "api/Memento.ReduxDevTool.ActionItemFromDevtool.html",
    "title": "Class ActionItemFromDevtool | Memento",
    "keywords": "Class ActionItemFromDevtool Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll public record ActionItemFromDevtool : IEquatable<ActionItemFromDevtool> Inheritance object ActionItemFromDevtool Implements IEquatable<ActionItemFromDevtool> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActionItemFromDevtool(string, JsonElement?, string?) public ActionItemFromDevtool(string Type, JsonElement? Payload, string? Source) Parameters Type string Payload JsonElement? Source string Properties Payload public JsonElement? Payload { get; init; } Property Value JsonElement? Source public string? Source { get; init; } Property Value string Type public string Type { get; init; } Property Value string"
  },
  "api/Memento.ReduxDevTool.Browser.BrowserReduxDevToolExtensions.html": {
    "href": "api/Memento.ReduxDevTool.Browser.BrowserReduxDevToolExtensions.html",
    "title": "Class BrowserReduxDevToolExtensions | Memento",
    "keywords": "Class BrowserReduxDevToolExtensions Namespace Memento.ReduxDevTool.Browser Assembly Memento.ReduxDevTool.Browser.dll public static class BrowserReduxDevToolExtensions Inheritance object BrowserReduxDevToolExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddBrowserReduxDevToolMiddleware(IServiceCollection, ReduxDevToolOption?, bool) Add BrowserReduxDevToolMiddleware to services. public static IServiceCollection AddBrowserReduxDevToolMiddleware(this IServiceCollection services, ReduxDevToolOption? option = null, bool isScoped = false) Parameters services IServiceCollection option ReduxDevToolOption isScoped bool It will be registered with AddScoped when true specified, otherwise AddSingleton. Returns IServiceCollection The service collection."
  },
  "api/Memento.ReduxDevTool.Browser.BrowserReduxDevToolMiddleware.html": {
    "href": "api/Memento.ReduxDevTool.Browser.BrowserReduxDevToolMiddleware.html",
    "title": "Class BrowserReduxDevToolMiddleware | Memento",
    "keywords": "Class BrowserReduxDevToolMiddleware Namespace Memento.ReduxDevTool.Browser Assembly Memento.ReduxDevTool.Browser.dll Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores on Browser. Interact with ReduxDevTools via JavaScript interop on Microsoft.JSInterop. public sealed class BrowserReduxDevToolMiddleware : Middleware, IDisposable Inheritance object Middleware BrowserReduxDevToolMiddleware Implements IDisposable Inherited Members Middleware.Handler Middleware.Dispose() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the BrowserReduxDevToolMiddleware class with the specified options and interop handler. Constructors BrowserReduxDevToolMiddleware(ReduxDevToolOption?) Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores on Browser. Interact with ReduxDevTools via JavaScript interop on Microsoft.JSInterop. public BrowserReduxDevToolMiddleware(ReduxDevToolOption? chromiumDevToolOption = null) Parameters chromiumDevToolOption ReduxDevToolOption The configuration options for the Redux Developer Tool middleware (optional). Remarks Initializes a new instance of the BrowserReduxDevToolMiddleware class with the specified options and interop handler. Methods Create(IServiceProvider) Creates a new ReduxDevToolMiddlewareHandler instance for the Redux Developer Tool middleware. protected override ReduxDevToolMiddlewareHandler Create(IServiceProvider provider) Parameters provider IServiceProvider The service provider used to resolve dependencies. Returns ReduxDevToolMiddlewareHandler A new ReduxDevToolMiddlewareHandler instance for the Redux Developer Tool middleware."
  },
  "api/Memento.ReduxDevTool.Browser.html": {
    "href": "api/Memento.ReduxDevTool.Browser.html",
    "title": "Namespace Memento.ReduxDevTool.Browser | Memento",
    "keywords": "Namespace Memento.ReduxDevTool.Browser Classes BrowserReduxDevToolExtensions BrowserReduxDevToolMiddleware Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores on Browser. Interact with ReduxDevTools via JavaScript interop on Microsoft.JSInterop."
  },
  "api/Memento.ReduxDevTool.ComputedState.html": {
    "href": "api/Memento.ReduxDevTool.ComputedState.html",
    "title": "Class ComputedState | Memento",
    "keywords": "Class ComputedState Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll public record ComputedState : IEquatable<ComputedState> Inheritance object ComputedState Implements IEquatable<ComputedState> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComputedState(object) public ComputedState(object State) Parameters State object Properties State [JsonPropertyName(\"state\")] public object State { get; init; } Property Value object"
  },
  "api/Memento.ReduxDevTool.HistoryStateContextJson.html": {
    "href": "api/Memento.ReduxDevTool.HistoryStateContextJson.html",
    "title": "Class HistoryStateContextJson | Memento",
    "keywords": "Class HistoryStateContextJson Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll public record HistoryStateContextJson : IEquatable<HistoryStateContextJson> Inheritance object HistoryStateContextJson Implements IEquatable<HistoryStateContextJson> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ActionsById [JsonPropertyName(\"actionsById\")] public required Dictionary<int, StoreAction> ActionsById { get; init; } Property Value Dictionary<int, StoreAction> ComputedStates [JsonPropertyName(\"computedStates\")] public required ComputedState[] ComputedStates { get; init; } Property Value ComputedState[] CurrentStateIndex [JsonPropertyName(\"currentStateIndex\")] public required int CurrentStateIndex { get; init; } Property Value int IsLocked [JsonPropertyName(\"isLocked\")] public bool IsLocked { get; init; } Property Value bool IsPaused [JsonPropertyName(\"isPaused\")] public bool IsPaused { get; init; } Property Value bool NextActionId [JsonPropertyName(\"nextActionId\")] public required int NextActionId { get; init; } Property Value int SkippedActionIds [JsonPropertyName(\"skippedActionIds\")] public required int[] SkippedActionIds { get; init; } Property Value int[] StagedActionIds [JsonPropertyName(\"stagedActionIds\")] public required int[] StagedActionIds { get; init; } Property Value int[]"
  },
  "api/Memento.ReduxDevTool.IDevToolInteropHandler.html": {
    "href": "api/Memento.ReduxDevTool.IDevToolInteropHandler.html",
    "title": "Interface IDevToolInteropHandler | Memento",
    "keywords": "Interface IDevToolInteropHandler Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll public interface IDevToolInteropHandler Properties MessageHandled Action<string>? MessageHandled { get; set; } Property Value Action<string> SyncRequested Action? SyncRequested { get; set; } Property Value Action Methods HandleMessage(string) void HandleMessage(string json) Parameters json string InitializeAsync(RootState) Task InitializeAsync(RootState state) Parameters state RootState Returns Task SendAsync(Command?, HistoryStateContextJson) Task SendAsync(Command? command, HistoryStateContextJson context) Parameters command Command context HistoryStateContextJson Returns Task"
  },
  "api/Memento.ReduxDevTool.ReduxDevToolMiddleware.html": {
    "href": "api/Memento.ReduxDevTool.ReduxDevToolMiddleware.html",
    "title": "Class ReduxDevToolMiddleware | Memento",
    "keywords": "Class ReduxDevToolMiddleware Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores. public sealed class ReduxDevToolMiddleware : Middleware, IDisposable Inheritance object Middleware ReduxDevToolMiddleware Implements IDisposable Inherited Members Middleware.Handler Middleware.Dispose() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the ReduxDevToolMiddleware class with the specified options and interop handler. Constructors ReduxDevToolMiddleware(IDevToolInteropHandler, ReduxDevToolOption?) Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores. public ReduxDevToolMiddleware(IDevToolInteropHandler devToolInterop, ReduxDevToolOption? chromiumDevToolOption = null) Parameters devToolInterop IDevToolInteropHandler chromiumDevToolOption ReduxDevToolOption The configuration options for the Redux Developer Tool middleware (optional). Remarks Initializes a new instance of the ReduxDevToolMiddleware class with the specified options and interop handler. Methods Create(IServiceProvider) Creates a new MiddlewareHandler instance for the Redux Developer Tool middleware. protected override MiddlewareHandler Create(IServiceProvider provider) Parameters provider IServiceProvider The service provider used to resolve dependencies. Returns MiddlewareHandler A new MiddlewareHandler instance for the Redux Developer Tool middleware."
  },
  "api/Memento.ReduxDevTool.ReduxDevToolMiddlewareHandler.html": {
    "href": "api/Memento.ReduxDevTool.ReduxDevToolMiddlewareHandler.html",
    "title": "Class ReduxDevToolMiddlewareHandler | Memento",
    "keywords": "Class ReduxDevToolMiddlewareHandler Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll public class ReduxDevToolMiddlewareHandler : MiddlewareHandler, IDisposable Inheritance object MiddlewareHandler ReduxDevToolMiddlewareHandler Implements IDisposable Inherited Members MiddlewareHandler.InitializedAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Reference to the redux devtool instrument. https://github.com/zalmoxisus/redux-devtools-instrument/blob/master/src/instrument.js Constructors ReduxDevToolMiddlewareHandler(IDevToolInteropHandler, IServiceProvider, ReduxDevToolOption) public ReduxDevToolMiddlewareHandler(IDevToolInteropHandler devtoolInteropHandler, IServiceProvider provider, ReduxDevToolOption option) Parameters devtoolInteropHandler IDevToolInteropHandler provider IServiceProvider option ReduxDevToolOption Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public override void Dispose() HandleProviderDispatch(RootState?, IStateChangedEventArgs, NextProviderMiddlewareCallback) Handles the provider dispatch. public override RootState? HandleProviderDispatch(RootState? state, IStateChangedEventArgs e, NextProviderMiddlewareCallback next) Parameters state RootState The current state. e IStateChangedEventArgs The event arguments. next NextProviderMiddlewareCallback The next middleware callback. Returns RootState The result of the next middleware callback. HandleStoreDispatch(object?, object?, NextStoreMiddlewareCallback) Handles the store dispatch. public override object? HandleStoreDispatch(object? state, object? command, NextStoreMiddlewareCallback next) Parameters state object The current state. command object The command being dispatched. next NextStoreMiddlewareCallback The next middleware callback. Returns object The result of the next middleware callback. OnInitializedAsync() Called when the store is initialized. protected override Task OnInitializedAsync() Returns Task A task representing the asynchronous operation. SendAsync(IStateChangedEventArgs, RootState, string) public Task SendAsync(IStateChangedEventArgs e, RootState rootState, string stackTrace) Parameters e IStateChangedEventArgs rootState RootState stackTrace string Returns Task"
  },
  "api/Memento.ReduxDevTool.ReduxDevToolOption.html": {
    "href": "api/Memento.ReduxDevTool.ReduxDevToolOption.html",
    "title": "Class ReduxDevToolOption | Memento",
    "keywords": "Class ReduxDevToolOption Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll Represents the configuration options for the Redux Developer Tool middleware. public record ReduxDevToolOption : IEquatable<ReduxDevToolOption> Inheritance object ReduxDevToolOption Implements IEquatable<ReduxDevToolOption> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Latency Gets or initializes the latency for the developer tool. public TimeSpan Latency { get; init; } Property Value TimeSpan MaximumHistoryLength Gets or initializes the maximum number of history entries stored by the developer tool. public uint MaximumHistoryLength { get; init; } Property Value uint Name Gets or initializes the name displayed in the developer tool. public string Name { get; init; } Property Value string OpenDevTool Gets or initializes a value indicating whether the developer tool should be opened by default. public bool OpenDevTool { get; init; } Property Value bool StackTraceEnabled Gets or initializes a value indicating whether stack traces are enabled in the developer tool. public bool StackTraceEnabled { get; init; } Property Value bool StackTraceLinesLimit Gets or initializes the limit of stack trace lines displayed in the developer tool. public int StackTraceLinesLimit { get; init; } Property Value int"
  },
  "api/Memento.ReduxDevTool.Remote.DevToolWebSocketConnection.html": {
    "href": "api/Memento.ReduxDevTool.Remote.DevToolWebSocketConnection.html",
    "title": "Class DevToolWebSocketConnection | Memento",
    "keywords": "Class DevToolWebSocketConnection Namespace Memento.ReduxDevTool.Remote Assembly Memento.ReduxDevTool.Remote.dll public class DevToolWebSocketConnection : IDisposable Inheritance object DevToolWebSocketConnection Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DevToolWebSocketConnection(string, ushort, bool) public DevToolWebSocketConnection(string hostName = \"0.0.0.0\", ushort port = 8000, bool secure = false) Parameters hostName string port ushort secure bool Properties IsDisposed public bool IsDisposed { get; } Property Value bool Methods DisconnectAsync(string) public Task DisconnectAsync(string id) Parameters id string Returns Task Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() InitializeAsync(RootState) public Task InitializeAsync(RootState _) Parameters _ RootState Returns Task ReplyHandshakeAsync(int, string) public Task ReplyHandshakeAsync(int cid, string id) Parameters cid int id string Returns Task SendAsync(string, HistoryStateContextJson) public Task SendAsync(string id, HistoryStateContextJson context) Parameters id string context HistoryStateContextJson Returns Task SendStartAsync(string) public Task SendStartAsync(string id) Parameters id string Returns Task Events ErrorOccurred public event Action<Exception>? ErrorOccurred Event Type Action<Exception> HandshakeRequested public event Action<int>? HandshakeRequested Event Type Action<int> MessageHandled public event Action<string, string>? MessageHandled Event Type Action<string, string> SendStartRequested public event Action? SendStartRequested Event Type Action SyncRequested public event Action<string>? SyncRequested Event Type Action<string>"
  },
  "api/Memento.ReduxDevTool.Remote.RemoteReduxDevToolMiddleware.html": {
    "href": "api/Memento.ReduxDevTool.Remote.RemoteReduxDevToolMiddleware.html",
    "title": "Class RemoteReduxDevToolMiddleware | Memento",
    "keywords": "Class RemoteReduxDevToolMiddleware Namespace Memento.ReduxDevTool.Remote Assembly Memento.ReduxDevTool.Remote.dll Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores via WebSocket. Connect applications such as Blazor Hybrid, Native Application, and Blazor Server that do not directly use a browser to Redux Dev Tools. public sealed class RemoteReduxDevToolMiddleware : Middleware, IDisposable Inheritance object Middleware RemoteReduxDevToolMiddleware Implements IDisposable Inherited Members Middleware.Handler Middleware.Dispose() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Initializes a new instance of the RemoteReduxDevToolMiddleware class with the specified options and interop handler. Constructors RemoteReduxDevToolMiddleware(ReduxDevToolOption?) Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores via WebSocket. Connect applications such as Blazor Hybrid, Native Application, and Blazor Server that do not directly use a browser to Redux Dev Tools. public RemoteReduxDevToolMiddleware(ReduxDevToolOption? devToolOption = null) Parameters devToolOption ReduxDevToolOption The configuration options for the Redux Developer Tool middleware (optional). Remarks Initializes a new instance of the RemoteReduxDevToolMiddleware class with the specified options and interop handler. Methods Create(IServiceProvider) Creates the handler for this middleware. protected override MiddlewareHandler Create(IServiceProvider provider) Parameters provider IServiceProvider The service provider. Returns MiddlewareHandler The created middleware handler."
  },
  "api/Memento.ReduxDevTool.Remote.RemoveReduxDevToolExtensions.html": {
    "href": "api/Memento.ReduxDevTool.Remote.RemoveReduxDevToolExtensions.html",
    "title": "Class RemoveReduxDevToolExtensions | Memento",
    "keywords": "Class RemoveReduxDevToolExtensions Namespace Memento.ReduxDevTool.Remote Assembly Memento.ReduxDevTool.Remote.dll public static class RemoveReduxDevToolExtensions Inheritance object RemoveReduxDevToolExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddRemoteReduxDevToolMiddleware(IServiceCollection, bool, ReduxDevToolOption?, string, ushort, bool) Add RemoteReduxDevToolMiddleware to services. public static IServiceCollection AddRemoteReduxDevToolMiddleware(this IServiceCollection services, bool isScoped = false, ReduxDevToolOption? chromiumDevToolOption = null, string hostName = \"0.0.0.0\", ushort port = 8000, bool secure = false) Parameters services IServiceCollection The services. isScoped bool It will be registered with AddScoped when true specified, otherwise AddSingleton. chromiumDevToolOption ReduxDevToolOption The middleware options. hostName string The proxy server hostname. port ushort The proxy server port. secure bool Https if true specified,otherwise Http. Returns IServiceCollection The service collection."
  },
  "api/Memento.ReduxDevTool.Remote.html": {
    "href": "api/Memento.ReduxDevTool.Remote.html",
    "title": "Namespace Memento.ReduxDevTool.Remote | Memento",
    "keywords": "Namespace Memento.ReduxDevTool.Remote Classes DevToolWebSocketConnection RemoteReduxDevToolMiddleware Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores via WebSocket. Connect applications such as Blazor Hybrid, Native Application, and Blazor Server that do not directly use a browser to Redux Dev Tools. RemoveReduxDevToolExtensions"
  },
  "api/Memento.ReduxDevTool.StoreAction.html": {
    "href": "api/Memento.ReduxDevTool.StoreAction.html",
    "title": "Class StoreAction | Memento",
    "keywords": "Class StoreAction Namespace Memento.ReduxDevTool Assembly Memento.ReduxDevTool.dll public record StoreAction : IEquatable<StoreAction> Inheritance object StoreAction Implements IEquatable<StoreAction> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Action [JsonPropertyName(\"action\")] public required ActionItem Action { get; init; } Property Value ActionItem Stack [JsonPropertyName(\"stack\")] public string? Stack { get; init; } Property Value string Timestamp [JsonPropertyName(\"timestamp\")] public required long Timestamp { get; init; } Property Value long Type [JsonPropertyName(\"type\")] public required string Type { get; init; } Property Value string"
  },
  "api/Memento.ReduxDevTool.html": {
    "href": "api/Memento.ReduxDevTool.html",
    "title": "Namespace Memento.ReduxDevTool | Memento",
    "keywords": "Namespace Memento.ReduxDevTool Classes ActionItem ActionItemFromDevtool ComputedState HistoryStateContextJson ReduxDevToolMiddleware Represents the Redux Developer Tool middleware used for debugging and profiling Redux stores. ReduxDevToolMiddlewareHandler ReduxDevToolOption Represents the configuration options for the Redux Developer Tool middleware. StoreAction Interfaces IDevToolInteropHandler"
  },
  "docs/BasicConcept.html": {
    "href": "docs/BasicConcept.html",
    "title": "Tutorial for C# with Console Application | Memento",
    "keywords": "Tutorial for C# with Console Application Take a look at an example of a simple console application to experience the basic concept. We provide a Store that allows you to share state between components. All stores are managed by a single provider and can subscribe to state change notifications. Unidirectional flow and immutable change of state provide a predictable architecture. In addition, we offer a store that easily implements Redo/Undo by managing immutable states. There are two ways to define a Store class that manages state. First, there is a simple store that only fires immutable state and state change events. Besides the simple store pattern, we also provide patterns inspired by MVU patterns such as Flux and Elm. Since you should change the state via the Reducer, you can change the state based on stricter rules and observe the state in detail. Store class Provides a way to change state directly. Suitable when simpler state management is required. State management may be intuitive and easy to understand because the state is changed by directly applying reducer functions. FluxStore class Based on the Flux architecture, this class is suitable when more rigorous state management is required. State changes via commands, so actions and state changes are separated. This facilitates logging and debugging of state changes. It facilitates consistent state management in complex applications and team development. Rules State should always be read-only. The UI then uses the new state to render its display. For patterns like Flux Every Reducer that processes in the action will create new state to reflect the old state combined with the changes expected for the action. To change state our app should Dispatch via Reducer in the action method Install Please install via package manager. dotnet add package Memento.Core dotnet add package Microsoft.Extensions.DependencyInjection Or install from Nuget https://www.nuget.org/packages/Memento.Core Define Store pattern In this section, you will learn the basic patterns of state management. Try to initialize state in your application, subscribe to it, and call actions to output state changes. Create a store for a simple counter application. This store, named AsyncCounterStore, will handle the count-up process and set-count process. Define the state It is preferable to make the state immutable, for example, by using a C# function record. This is to ensure consistency even if the state changes unexpectedly or is referenced from various locations. It is also necessary to use ReduxDevTools or similar tools to perform time travel. First, define the state that the store will manage: create a record named AsyncCounterState. This record contains properties that store the current count, history, and loading state. public record AsyncCounterState { public int Count { get; init; } = 0; public ImmutableArray<int> History { get; init; } = []; public bool IsLoading { get; init; } = false; } Define Store Next, create a store class named AsyncCounterStore. This class inherits from Store . public class AsyncCounterStore() : Store<AsyncCounterState>(() => new()) { } Add actions to store to change store state Implement the CountUpAsync method to perform asynchronous count-up processing. This method first sets the loading state to true, then waits for a certain period of time using Task.Delay. It then calls the HandleIncrement method to increment the count and finally sets the loading state to false. And implement the SetCount method to allow the user to set the count with a specified number. This method takes the current state and returns a new state with a new count value and updated history. public async Task CountUpAsync() { Mutate(state => state with { IsLoading = true }); await Task.Delay(500); Mutate(HandleIncrement); Mutate(state => state with { IsLoading = false }); } private static AsyncCounterState HandleIncrement(AsyncCounterState state) { var count = state.Count + 1; return state with { Count = count, History = state.History.Add(count), }; } public void SetCount(int num) { Mutate(state => state with { Count = num, History = state.History.Add(num), }); } Overview Completes the implementation of the AsyncCounterStore class. This store simplifies application state management. Below is the code for the completed AsyncCounterStore class. // Define state to manage in store public record AsyncCounterState { public int Count { get; init; } = 0; public ImmutableArray<int> History { get; init; } = []; public bool IsLoading { get; init; } = false; } public class AsyncCounterStore() : Store<AsyncCounterState>(() => new()) { public async Task CountUpAsync() { Mutate(state => state with { IsLoading = true }); await Task.Delay(500); Mutate(HandleIncrement); Mutate(state => state with { IsLoading = false }); } private static AsyncCounterState HandleIncrement(AsyncCounterState state) { var count = state.Count + 1; return state with { Count = count, History = state.History.Add(count), }; } public void SetCount(int num) { Mutate(state => state with { Count = num, History = state.History.Add(num), }); } } Includes the typed Message explaining what the change has been in StateHasChangedEventArgs Store<TState, TMessage> allows you to have a typed message explaining what the change has been in StateHasChangedEventArgs when mutating the State of the Store. The default message type is string if unspecified, such as in Store<TState>. Usage Define the message type. public enum StateChangedType { BeginLoading, EndLoading, SetCount, Increment } The message type is specified in Store Type params in the following way. Store<AsyncCounterState, StateChangedType> If you set message as the second argument of Mutate(..., StateChangedType.Increment), you can get the message from the StateHasChangedEventArgs. store.Subscribe(e => { Console.WriteLine(e.Command.Message.StateChangedType); // Specified Paylaod }); Sample CounterStore Overview public record CounterStoreState { public int Count { get; init; } = 0; public ImmutableArray<int> History { get; init; } = []; public bool IsLoading { get; init; } = false; } public enum StateChangedType { BeginLoading, EndLoading, SetCount, Increment } public class CounterStore() : Store<CounterStoreState, StateChangedType>(() => new()) { public async Task CountUpAsync() { Mutate(state => state with { IsLoading = true }, StateChangedType.BeginLoading); await Task.Delay(500); Mutate(HandleIncrement, StateChangedType.Increment); Mutate(state => state with { IsLoading = false }, StateChangedType.EndLoading); } private static CounterStoreState HandleIncrement(CounterStoreState state) { var count = state.Count + 1; return state with { Count = count, History = state.History.Add(count), }; } public void SetCount(int num) { Mutate(state => state with { Count = num, History = state.History.Add(num), }, StateChangedType.SetCount); } } Sample Source https://github.com/le-nn/memento/blob/main/samples/Memento.Sample.Blazor/Stores/AsyncCounterStore.cs Define FluxStore pattern In the previous section, we implemented AsyncCounterStore using the Store pattern. This time, let's implement the same features using the FluxStore pattern. In this section, you will learn how to use the AsyncCounterStore to manage the state of your counters. Skip this section if you do not use the FluxStore pattern. FluxPattern is one of the architectural patterns for managing application data flow in React applications. This pattern uses unidirectional data flow to manage application state changes. These elements are similar to the Model-View-Update (MVU) architectural pattern, which represents the application state as a model and uses it to display it in the View. State changes are managed by the Update function, which is then reflected in the View. FluxStore is inspired by React's Flux and MVU patterns. If you want to manage state with stricter rules and observe more detailed state change events, FluxStore is the right choice. By mutating via Command, we have tighter control over all state changes. Let's take a look at the tutorial. Define the state First, define the state to be managed in the store. In this example, create a record named AsyncCounterState. public record AsyncCounterState { public int Count { get; init; } = 0; public ImmutableArray<int> History { get; init; } = []; public bool IsLoading { get; init; } = false; } Define commands Define the commands used to change the state. create an AsyncCounterCommand record and add subrecords to define each command. public record AsyncCounterCommand : Command { public record Increment : AsyncCounterCommand; public record BeginLoading : AsyncCounterCommand; public record EndLoading : AsyncCounterCommand; public record ModifyCount(int Value) : AsyncCounterCommand; } Create a store Create an AsyncCounterStore class and extend FluxStore. In this class, define the state initialization and reducer functions. public class AsyncCounterStore() : FluxStore<AsyncCounterState, AsyncCounterCommand>(() => new(), Reducer) { } Denine Reducer The Reducer uses the current state and command to create a new state; define a Reducer function in the AsyncCounterStore class. // State can change via Reducer and easy to observe state from command // Reducer generate new state from command and current state static AsyncCounterState Reducer(AsyncCounterState state, AsyncCounterCommand? command) { return command switch { AsyncCounterCommand.BeginLoading => state with { IsLoading = true }, AsyncCounterCommand.EndLoading => state with { IsLoading = false }, AsyncCounterCommand.Increment => HandleIncrement(state), AsyncCounterCommand.ModifyCount(var val) => state with { Count = val, History = state.History.Add(val), }, _ => throw new CommandNotHandledException<AsyncCounterCommand>(command), }; } static AsyncCounterState HandleIncrement(AsyncCounterState state) { var count = state.Count + 1; return state with { Count = count, History = state.History.Add(count), }; } Add actions to store As with the Store section add actions to change the state from outside the store. In this example, two actions are defined, CountUpAsync and SetCount. Since the creation of the new state is done by the Reducer, the command is dispatched to entrust it to the Reducer. // \"Dispatch\" method can called outside of store via action (public method) // Action can be async method. public async Task CountUpAsync() { this.Dispatch(new BeginLoading()); await Task.Delay(500); this.Dispatch(new Increment()); this.Dispatch(new EndLoading()); } public void SetCount(int num) { this.Dispatch(new ModifyCount(num)); } Overview // Define state to manage in store public record AsyncCounterState { public int Count { get; init; } = 0; public ImmutableArray<int> History { get; init; } = ImmutableArray.Create<int>(); public bool IsLoading { get; init; } = false; } // Define messages to change state and observe state change event in detail. public record AsyncCounterCommand : Command { public record Increment : AsyncCounterCommand; public record BeginLoading : AsyncCounterCommand; public record EndLoading : AsyncCounterCommand; public record ModifyCount(int Value) : AsyncCounterCommand; } public class AsyncCounterStore() : FluxStore<AsyncCounterState, AsyncCounterCommand>(() => new(), Reducer) { // State can change via Reducer and easy to observe state from command // Reducer generate new state from command and current state static AsyncCounterState Reducer(AsyncCounterState state, AsyncCounterCommand command) { return command switch { BeginLoading => state with { IsLoading = true }, EndLoading => state with { IsLoading = false }, Increment => HandleIncrement(state), ModifyCount(var val) => state with { Count = val, History = state.History.Add(val), }, _ => throw new CommandNotHandledException<AsyncCounterCommand>(command), }; } static AsyncCounterState HandleIncrement(AsyncCounterState state) { var count = state.Count + 1; return state with { Count = count, History = state.History.Add(count), }; } // \"Dispatch\" method can called outside of store via action (public method) // Action can be async method. public async Task CountUpAsync() { this.Dispatch(new BeginLoading()); await Task.Delay(500); this.Dispatch(new Increment()); this.Dispatch(new EndLoading()); } public void SetCount(int num) { this.Dispatch(new ModifyCount(num)); } } Usage of Store You seemed to create Store or FluxStore the usage is the same for both. StoreProvider The StoreProvider provides centralized management of related Stores and a single StateTree representation of the related Stores' States. It also centrally manages Stores' state change notifications and events. Initializing Store and StoreProvider StoreProvider initialization requires an IServiceProvider with the associated services and stores registered. var services = new ServiceCollection(); services.AddScoped<AsyncCounterStore>(); var serviceProvider = new ServiceCollection() .AddScoped<AsyncCounterStore>() .BuildServiceProvider(); var provider = new StoreProvider(serviceProvider); Capture the StateTree that consists from all aggregated store states The StateTree is represented by a IDictionary<string, object>. The key is store name and the value is store state. var rootState = provider.CaptureRootState(); rootState is following { \"Store1\" : { \"Count1\" : 1234, \"Count2\" : 4567, }, // other stores ... \"AsyncCounterStore\" : { \"Count\": 0, \"History\": [], \"IsLoading\": false } } Subscribing A listener is registered for state change events so that processing can be performed each time the state changes. In this example, logs are output to the console each time the state changes. The provider subscribes to all store state change events and outputs in JSON to the console. The store subscribes to the store state change events and output in JSON to console. Whenever a state change occurs, an event is emitted from the monitored store (all stores or a specific store) and information related to that event is printed to the console. This output includes event types, state changes, and is presented in formatted JSON using the JsonSerializer. // Observe all stores state provider.Subscribe(e => { Console.WriteLine(); Console.WriteLine($\"// {e.StateChangedEvent.Message?.GetType().Name}\"); Console.WriteLine(JsonSerializer.Serialize( e.StateChangedEvent.State, new JsonSerializerOptions() { WriteIndented = true }) ); }); var store = provider.ResolveStore<AsyncCounterStore>(); // Observe a store state store.Subscribe(e => { Console.WriteLine(); Console.WriteLine($\"// {e.Message.GetType().Name}\"); Console.WriteLine(JsonSerializer.Serialize( e.State, new JsonSerializerOptions() { WriteIndented = true }) ); }); Console.WriteLine(\"// Initial state\"); Console.WriteLine(JsonSerializer.Serialize( store.State, new JsonSerializerOptions() { WriteIndented = true }) ); Call actions The application calls the store's actions to change the state. In this example, two actions are called, CountUpAsync and SetCount. // Call action and countup async. await store.CountUpAsync(); // Call action and set count. store.SetCount(5); store.Subscribe can be exptected output following // Initial state { \"Count\": 0, \"History\": [], \"IsLoading\": false } // BeginLoading { \"Count\": 0, \"History\": [], \"IsLoading\": true } // 500ms later // Increment { \"Count\": 1, \"History\": [ 1 ], \"IsLoading\": true } // EndLoading { \"Count\": 1, \"History\": [ 1 ], \"IsLoading\": false } // ModifyCount { \"Count\": 5, \"History\": [ 1, 5 ], \"IsLoading\": false } Now you know how to use AsyncCounterStore to manage application state. If the state becomes complex, consider creating multiple stores and splitting the state or sharing state between stores. These approaches make application state management more effective and efficient. As an application grows and different features and components are added, state management can become complex. In such cases, state management can be facilitated by using multiple stores to partition state. Individual stores can be used to manage state related to specific features or components. When sharing state among multiple stores or UI components, state can be shared using parent components or contexts. This ensures consistency of state and synchronizes state across the application. Applying these methods makes application state management scalable and maintainable, improves code reusability, and simplifies development. Depending on the requirements of each application, choose the best state management approach. Next step In the Next tutorial you will learn how to update the actual UI in Blazor ! See"
  },
  "docs/Blazor.html": {
    "href": "docs/Blazor.html",
    "title": "Getting Standard | Memento",
    "keywords": "Getting Standard In this tutorial, you will learn how to update the actual UI in Blazor ! Install Memento.Blazor in the Blazor component to update the Store state. Memento.Blazor contains components that allow UI components to know about state updates and automatically update the UI. Memento.Core is included in the dependencies and does not need to be installed additionally. Memento.Core is a core library consisting of pure .NET code only. NET class library or for console apps that do not use a UI framework such as Blazor, install Memento.Core. Depends on Microsoft.AspNetCore.Components. It can also be used with native UI frameworks such as MobileBlazorBindings and BlazorBindings.Maui because it does not depend on Microsoft.AspNetCore.Components.Web. Blazor https://docs.microsoft.com/ja-jp/aspnet/core/blazor/ https://dotnet.microsoft.com/ja-jp/apps/aspnet/web-apps/blazor MobileBlazorBindings https://github.com/dotnet/MobileBlazorBindings BlazorBindings.Maui https://github.com/Dreamescaper/BlazorBindings.Maui Install Install Memento.Blazor for the Blazor projects. Install Memento.Core for the pure NET project that do not use the UI framework like .NET Class library or Console App. Install with CLI Memento.Blazor dotnet add package Memento.Blazor Memento.Core dotnet add package Memento.Core Install from Nuget Memento.Blazor Nuget https://www.nuget.org/packages/Memento.Blazor Memento.Core Nuget https://www.nuget.org/packages/Memento.Core Initialization Blazor uses Dependency Injection in the framework. Here is how to use Memento in your application. Registers all required modules with AddMemento() . Registers all the stores present in the specified assembly with ScanAssemblyAndAddStores() . Specifically, all classes that inherit from ````IStore``` will be registered. registers an individual Store specified by AddStore<TStore>() . Register the required services in Program.cs etc. Add middleware with ```AddMiddleware(...)`` . Add middleware if necessary. If isScoped: false, it will be registered as a Singleton, if isScoped: true, it will be registered as a Scoped service. In the case of Blazor Server, the state is separated for each user session, so the argument isScoped: true must be set or the state will be shared by all users. The default args is isScoped: true. using Memento.Blazor; var builder = WebAssemblyHostBuilder.CreateDefault(args); builder.RootComponents.Add<App>(\"#app\"); builder.RootComponents.Add<HeadOutlet>(\"head::after\"); builder.Services // Add necessary modules to Memento .AddMemento(isScoped: false) // Add middleware .AddMiddleware<LoggerMiddleware>(isScoped: false) // Add by specifying Store .AddStore<AsyncCounterStore>(isScoped: false) // Scan the assembly and register all classes that implement the IStore interface .ScanAssemblyAndAddStores(typeof(Program).Assembly, isScoped: false); await builder.Build().RunAsync(); Next, MementoInitializer to the component root, such as App.razor. This will initialize the necessary Memento modules. <MementoInitializer /> <Router AppAssembly=\"@typeof(App).Assembly\"> <Found Context=\"routeData\"> <RouteView RouteData=\"@routeData\" DefaultLayout=\"@typeof(MainLayout)\" /> <FocusOnNavigate RouteData=\"@routeData\" Selector=\"h1\" /> </Found> <NotFound> <PageTitle>Not found</PageTitle> <LayoutView Layout=\"@typeof(MainLayout)\"> <p role=\"alert\">Sorry, there's nothing at this address.</p> </LayoutView> </NotFound> </Router> Component usage Using @inject in Store will be automatically resolved by the DI container. By inheriting from ObserverComponent. Injected Stores that extend Store<TState> or FluxStore<TState, TCommand> are automatically observed by reflection. This allows the View to automatically update the state of the Store automatically This is an example of Counter. @using Memento.Sample.Blazor.Stores @using System.Text.Json @page \"/counter\" @inherits ObserverComponent @inject AsyncCounterStore AsyncCounterStore <PageTitle>Counter</PageTitle> <div> <h1 class=\"mt-5\">Async Counter</h1> <h2>Current count: @AsyncCounterStore.State.Count</h2> <p>Loading: @AsyncCounterStore.State.IsLoading</p> <div> <button class=\"mt-3 btn btn-primary\" @onclick=\"IncrementCount\">Count up</button> <button class=\"mt-3 btn btn-primary\" @onclick=\"CountupMany\">Count up 100 times</button> </div> <div class=\"mt-5\"> <h3>Count up async with histories</h3> <button class=\"mt-3 btn btn-primary\" @onclick=\"IncrementCountAsync\">Count up async</button> <p class=\"mt-3 mb-0\">Histories</p> <div class=\"d-flex\"> @foreach (var item in string.Join(\", \", AsyncCounterStore.State.Histories)) { @item } </div> </div> <div class=\"mt-5\"> <h3>Count up with Amount</h3> <input @bind-value=\"_amount\" /> </div> <button class=\"mt-3 btn btn-primary\" @onclick=\"CountupWithAmount\">Count up with amount</button> <div class=\"mt-5\"> <h3>Set count</h3> <input @bind-value=\"_countToSet\" /> </div> <button class=\"mt-3 btn btn-primary\" @onclick=\"SetCount\">Count up with amount</button> </div> @code { int _amount = 5; int _countToSet = 100; void IncrementCount() { AsyncCounterStore.CountUp(); } async Task IncrementCountAsync() { await AsyncCounterStore.CountUpAsync(); } void CountupMany() { AsyncCounterStore.CountUpManyTimes(100); } void CountupWithAmount() { AsyncCounterStore.CountUpWithAmount(_amount); } void SetCount() { AsyncCounterStore.SetCount(_countToSet); } } Another way to use If inherit cannot be used due to conflicts with other libraries, please use StateChangedObserver. If you specify IObservable for Observables, it will automatically track state changes and notify OnStateHasChanged. <StateChangedObserver Observables=\"[Store1, Store2, Store3]\" OnStateHasChanged=\"StateHasChanged\" /> sample @page \"/counter\" @inject AsyncCounterStore AsyncCounterStore <PageTitle>Counter</PageTitle> <StateChangedObserver Observables=\"[AsyncCounterStore]\" OnStateHasChanged=\"StateHasChanged\" /> <div> <h1 class=\"mt-5\">Async Counter</h1> <h2>Current count: @AsyncCounterStore.State.Count</h2> <p>Loading: @AsyncCounterStore.State.IsLoading</p> </div>"
  },
  "docs/Middleware.html": {
    "href": "docs/Middleware.html",
    "title": "What is Middleware | Memento",
    "keywords": "What is Middleware Middleware can be implemented to interrupt the process when updating the state. Middleware can be extended for various purposes, such as implementing your own Logger or supporting ReduxDevTools. Middleware pipeline Middleware is a component built into the StoreProvider and Store pipeline to interrupt another function in the state change process. A StoreProvider can have multiple middlewares registered. The middleware is interrupted by state changes like a chain and is connected to the chain . The middleware is connected like a chain. Each delegate can perform operations before and after the next delegate. How to actually interrupt the State Changes Suppose Middleware is registered with the service as follows services.AddMiddleware(() => new Middleware1()); services.AddMiddleware(() => new Middleware2()); services.AddMiddleware(() => new Middleware3()); Pipelines are built in the order in which they are registered The specific code looks like this The NextProviderMiddlewareCallback argument is a delegate handler that calls the next middleware to be connected. If the state is not changed, handle the next middleware and return the result. return next(state, e); If you return null in middleware handler, the state change is canceled and no state change event is fired. return null; // Middleware1 public override RootState? HandleProviderDispatch(RootState? state, StateChangedEventArgs e, NextProviderMiddlewareCallback next) { // pre logic var handledState = next(state, e); // Handle Middleware2 // post logic return handledState; // The state changes will be canceled if handleState is null } // Middleware2 public override RootState? HandleProviderDispatch(RootState? state, StateChangedEventArgs e, NextProviderMiddlewareCallback next) { // pre logic var handledState = next(state, e); // Handle Middleware3 // post logic return handledState; } // Middleware3 public override RootState? HandleProviderDispatch(RootState? state, StateChangedEventArgs e, NextProviderMiddlewareCallback next) { // pre logic var handledState = next(state, e); // Handle Middleware4 // post logic return handledState; } // ... They are based on the Middleware pattern and They function like ASP.NET Core Middleware. https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0 Implements Middleware and MiddlewareHandler Let's look at a more concrete implementation Implement your own Middleware by inheriting from Middleware abstract class. The Middleware abstract class can only inherit from Create a MiddlewareHandler by simply overriding MiddlewareHandler Create(IServiceProvider provider) . The actual functionality and implementation is delegated to MiddlewareHandler. To interrupt state updates, override HandleProviderDispatch() or HandleStoreDispatch . HandleProviderDispatch(...) overrides StoreProviderDispatch() when StoreProvider detects a state update. StoreProvider handles when it detects a state update, that is, when the state of one of the application's Stores changes. HandleStoreDispatch(...) handles only the Store whose state has been updated. The following example overrides HandleProviderDispatch(...) overrides StoreProvider and interrupts the state change with StoreProvider . The log is handled when the state of any Store is changed. The argument RootState is an IDictionary<TKey, TValue> that represents all StateTrees managed by StoreProvider . The next of NextProviderMiddlewareCallback argument is a delegate handler that calls the next connected middleware. If you don't want to change state, process the next middleware and return the result. return next(state, e); If you return null, the state change is canceled and no state change event is fired. return null; However, if you return null, the connection is still active. However, even if you return null, it is possible that some state may be returned by the previous middleware that is connected to it. LoggerMiddlewareHandler.HandleProviderDispatch(...) implements only return next(state, e); by default. The HandleStoreDispatch does the same. However, if the object to be returned does not match the type of State managed by the Store, an exception will be thrown. LoggerMiddleware This is an example of LoggerMiddleware. It handles StoreProvider and outputs a log of all state changes to the console. /// <summary> /// Middleware for logging state changes. /// </summary> public sealed class LoggerMiddleware : Middleware { /// <summary> /// Creates a new instance of the LoggerMiddlewareHandler. /// </summary> /// <param name=\"provider\">The service provider used to resolve required services.</param> /// <returns>A new LoggerMiddlewareHandler instance.</returns> protected override MiddlewareHandler Create(IServiceProvider provider) { return new LoggerMiddlewareHandler( provider.GetRequiredService<IJSRuntime>() ); } /// <summary> /// Handler for logging state changes in the LoggerMiddleware. /// </summary> public class LoggerMiddlewareHandler : MiddlewareHandler { private readonly IJSRuntime _jSRuntime; /// <summary> /// Creates a new instance of the LoggerMiddlewareHandler. /// </summary> /// <param name=\"jSRuntime\">The JavaScript runtime to be used for logging.</param> public LoggerMiddlewareHandler(IJSRuntime jSRuntime) { _jSRuntime = jSRuntime; } /// <summary> /// Handles logging the state changes before passing them to the next middleware. /// </summary> /// <param name=\"state\">The current state of the application.</param> /// <param name=\"e\">The state change event arguments.</param> /// <param name=\"next\">The next middleware in the pipeline.</param> /// <returns>The updated state after processing by the middleware pipeline.</returns> public override RootState? HandleProviderDispatch(RootState? state, StateChangedEventArgs e, NextProviderMiddlewareCallback next) { _ = HandleLog(state, e); return next(state, e); } /// <summary> /// Logs the state changes using the JavaScript console. /// </summary> /// <param name=\"state\">The current state of the application.</param> /// <param name=\"e\">The state change event arguments.</param> /// <returns>A task representing the logging operation.</returns> public async Task HandleLog(object? state, StateChangedEventArgs e) { if (state is null) { return; } await _jSRuntime.InvokeVoidAsync(\"console.log\", new { StateName = state.GetType().Name, State = state, EventArgs = e, }); } } } Register middleware instances to IServiceCollection in callback. builder.Services.AddMiddleware(() => new LoggerMiddleware()); DEMO Here is sample code for this tutorial. https://github.com/le-nn/memento/blob/main/samples/Memento.Sample.BlazorWasm/LoggerMiddleware.cs or https://github.com/le-nn/memento/blob/main/samples/Memento.Sample.BlazorServer/LoggerMiddleware.cs The LoggerMiddleware is implemented in the Memento sample on the DEMO page and can be found in the console tab of Chrome's DevTool. https://le-nn.github.io/memento/"
  },
  "docs/README.html": {
    "href": "docs/README.html",
    "title": "Basic Concept | Memento",
    "keywords": "Basic Concept Easy unidirectional store and redo/undo library for state management for frontend apps on Blazor/.NET We provides a Store that allows you to share state between components. All stores are managed by a single provider and can subscribe to state change notifications. Undirectional flow and immutable change of state provides a predictable architecture. In addition, we provide a store that easily implements Redo/Undo by managing in immutable states. DEMO Page https://le-nn.github.io/memento/ If you have ReduxDevTool installed, DevTool will launch automatically. You can do state history and time travel. See ReduxDevTools Docs for details of usage. Features Less boilerplate, less rule and simple usage Immutable state and Unidirectional flow Multiple stores but manged by single provider, so can observe and manage as one state tree Observe detailed status with command patterns and makes it easier to monitor what happened within the application Compatibility and bindings Package Name Platform Desctiption Memento.Core .NET 8 or later Core Package of Memento Memento.Blazor .NET 8 or later Provides Observing state changes on Blazor Component. Memento.ReduxDevTool.Remote .NET 8 or later Connect and Interact with applications via WebSocket. Memento.ReduxDevTool.Browser .NET 8 or later Interact with ReduxDevTools via JavaScript interop. Memento.ReduxDevTool .NET 8 or later Provides basic functionality to interact with ReduxDevTools. Interop is required. Tutorials Link Summary BasicConcept with C# The tutorials for implemented with pure C# in simple console application. Update UI with Blazor Practical Uses of the Framework. In practice, it is mostly used with UI frameworks. Here is a tutorial on how to use it with Blazor. Middleware Middleware can be implemented to interrupt the process when updating the state. Middleware can be extended for various purposes, such as implementing your own Logger or supporting ReduxDevTools. Redux Dev Tools ReduxDevTools is a tool for debugging application's state changes. State can be time traveled and history can be viewed in ReduxDevTools. Redo / Undo Redo/Undo is a feature that allows you to undo and redo state changes. Samples C# with Console App Blazor App Shared Blazor Wasm App Blazor Server App"
  },
  "docs/RedoUndo.html": {
    "href": "docs/RedoUndo.html",
    "title": "ReDo/UnDo | Memento",
    "keywords": "ReDo/UnDo Memento.Core.History.HistoryManager is a class that manages the redo/undo state context. It gives you a generic ReDo/UnDo. Here is an example of how to use it. @using Memento.Core.History; <PageTitle>Index</PageTitle> <h1>Redo / Undo Counter</h1> <button disabled=\"@(!_historyManager.CanUnDo)\" @onclick=\"() => _historyManager.UnDoAsync()\">UnDo</button> <button disabled=\"@(!_historyManager.CanReDo)\" @onclick=\"() => _historyManager.ReDoAsync()\">ReDo</button> <h2>@_count</h2> <button @onclick=\"CountUp\">Count Up</button> @code { readonly HistoryManager _historyManager = new() { MaxHistoryCount = 20 }; int _count = 0; async Task CountUp() { await _historyManager.CommitAsync( async () => { var count = _count; _count++; return new { Count = count, }; }, async state => { _count = state.Count; } ); } } MaxHistoryCount is the maximum number that can be saved. Disabling button with CanUnDo/CanReDo. Take a snapshot of the current State with CommitAsync. The first argument callback is called when \"Do\" or \"ReDo\" is performed, and retains the returned Context as a Snapshot. The first callback should be implemented to create and take snapshot of the state when \"Do\" or \"ReDo\" performed. The second argument callback is called when \"UnDo\" is performed. The second callback should be implemented to Restore the state from the snapshot of the state when \"UnDo\" performed. With Store Memento.Core.MementoStore or Memento.Core.FluxMementoStore allows you to manage the redo/undo state context in the store. Specify the HistoryManager instance as the second argument of base() constructor. You can share context across stores. Invoking CommitAsync preserves the current State, which can be restored with UnDoAsync and ReDoAsync. Unlike HistoryManager.CommitAsync, there is no need to manually assign state. The state at the time Store.CommitAsync was invoked is automatically restored. The first argument callback is called when \"Do\" or \"ReDo\" is performed, The returned value is retained as a payload to receive when the second argument callback is called. The first callback should be implemented to create a payload when \"Do\" or \"ReDo\" performed. The second argument callback is called when \"UnDo\" is performed. The second callback should be implemented handling such as removing items with a received payload from the DB or Server etc. Sample with ToDo public record RedoUndoTodoState { public ImmutableArray<Todo> Todos { get; init; } = []; public bool IsLoading { get; init; } } public class RedoUndoTodoStore(ITodoService todoService) : MementoStore<RedoUndoTodoState>(() => new(), new() { MaxHistoryCount = 20 }) { readonly ITodoService _todoService = todoService; public async Task CreateNewAsync(string text) { var id = Guid.NewGuid(); await CommitAsync( async () => { var item = await _todoService.CreateItemAsync(id, text); Mutate(state => state with { Todos = state.Todos.Add(item), }); return item; }, async todo => { await _todoService.RemoveAsync(todo.Payload.TodoId); } ); } public async Task LoadAsync() { Mutate(state => state with { IsLoading = true }); var items = await _todoService.FetchItemsAsync(); Mutate(state => state with { Todos = items, }); Mutate(state => state with { IsLoading = false }); } public async Task ToggleIsCompletedAsync(Guid id) { await CommitAsync( async () => { var state = State; var item = await _todoService.ToggleCompleteAsync(id) ?? throw new Exception(\"Failed to toggle an item in Do or ReDo.\"); Mutate(state => state with { Todos = state.Todos.Replace( state.Todos.Where(x => id == x.TodoId).First(), item ) }); return item; }, async p => { var item = await _todoService.ToggleCompleteAsync(id) ?? throw new Exception(\"Failed to toggle an item in UnDo.\"); } ); } } @using Memento.Sample.Blazor.Stores @using System.Text.Json @inherits ObserverComponent @inject AsyncCounterStore AsyncCounterStore <div class=\"p-4 mt-4 bg-opacity-10 bg-dark rounded-2\"> <h1 class=\"\">Async Counter Component</h1> <h2>Current count: @AsyncCounterStore.State.Count</h2> <p>Loading: @AsyncCounterStore.State.IsLoading</p> <div> <button class=\"mt-3 btn btn-primary\" @onclick=\"IncrementCount\">Count up</button> <button class=\"mt-3 btn btn-primary\" @onclick=\"CountUpMany\">Count up 100 times</button> </div> <div class=\"mt-5\"> <h3>Count up async with histories</h3> <button class=\"mt-3 btn btn-primary\" @onclick=\"IncrementCountAsync\">Count up async</button> <p class=\"mt-3 mb-0\">Histories</p> <div class=\"d-flex\"> @foreach (var item in string.Join(\", \", AsyncCounterStore.State.Histories)) { @item } </div> </div> <div class=\"mt-5\"> <h3>Count up with Amount</h3> <input @bind-value=\"_amount\" /> </div> <button class=\"mt-3 btn btn-primary\" @onclick=\"CountUpWithAmount\">Count up with amount</button> <div class=\"mt-5\"> <h3>Set count</h3> <input @bind-value=\"_countToSet\" /> </div> <button class=\"mt-3 btn btn-primary\" @onclick=\"SetCount\">Count up with amount</button> </div> @code { int _amount = 5; int _countToSet = 100; void IncrementCount() { AsyncCounterStore.CountUp(); } async Task IncrementCountAsync() { await AsyncCounterStore.CountUpAsync(); } void CountUpMany() { AsyncCounterStore.CountUpManyTimes(100); } void CountUpWithAmount() { AsyncCounterStore.CountUpWithAmount(_amount); } void SetCount() { AsyncCounterStore.SetCount(_countToSet); } } Sample Source https://github.com/le-nn/memento/blob/main/samples/Memento.Sample.Blazor/Stores/RedoUndoTodoStore.cs https://github.com/le-nn/memento/blob/main/samples/Memento.Sample.Blazor/Components/Counter.razor DEMO https://le-nn.github.io/memento/todo"
  },
  "docs/ReduxDevTools.html": {
    "href": "docs/ReduxDevTools.html",
    "title": "Redux Dev Tools | Memento",
    "keywords": "Redux Dev Tools Redux DevTools is supported. Redux DevTools is a tool for debugging application's state changes. State can be time traveled and history can be viewed in DevTools. Currently, memento is supported most features of ReduxDevTools. There are two types of Middleware for ReduxDevTools. One is Memento.ReduxDevTool.Browser that interacts via Javascript The other is Memento.ReduxDevTool.Remote which interacts via WebSocket. Memento.ReduxDevTool.Browser Works with Blazor Server and Blazor Wasm. Interact with ReduxDevTools via JavaScript interop on Microsoft.JSInterop. Memento.ReduxDevTool.Remote Connect and Interact with applications via WebSocket. You can use ReduxDevTool even in environments that do not use a direct browser, such as Blazor Hybrid, Native Application, and Blazor Server. Not available for Browser applications such as Blazor WASM as it must support System.Net Usage To enable develop integration, follow these steps 1. Install Redux DevTool Extension into Your Browser It can be used as a browser extension for Edge, Chrome and FireFox. Chrome https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd Edge https://microsoftedge.microsoft.com/addons/detail/redux-devtools/nnkgneoiohoecpdiaponcejilbhhikei FireFox https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/ You can see the all docs for extension on official Github repos. https://github.com/reduxjs/redux-devtools 2. Install the memento middleware from Nuget package CLI Case of Blazor WASM or Blazor Server dotnet add package Memento.ReduxDevTool.Browser Case of Native app, Blazor MAUI or Blazor Server dotnet add package Memento.ReduxDevTool.Remote Nuget Memento.ReduxDevTool.Browser https://www.nuget.org/packages/Memento.ReduxDevTool.Browser Memento.ReduxDevTool.Remote https://www.nuget.org/packages/Memento.ReduxDevTool.Remote 3. Register services This might be a security flaw, so you should only reference this package in Debug builds. Case of Memento.ReduxDevTool.Browser using Memento.ReduxDevTool.Browser; #if DEBUG builder.Services.AddBrowserReduxDevToolMiddleware(new() { StackTraceEnabled = true, OpenDevTool = true, ... }); #endif Case of Memento.ReduxDevTool.Browser; using Memento.ReduxDevTool.Remote; #if DEBUG builder.Services.AddRemoteReduxDevToolMiddleware( false, new() { StackTraceEnabled = true, OpenDevTool = true, ... } ); #endif Boot Redux DevTools Press F12 to open the developer tool and select the Redux tab. All Store states in an application are represented as a single StateTree. Redux Dev Tools middleware API Reference API Reference for ReduxDevTools middleware. AddBrowserReduxDevToolMiddleware Extension Register the middleware to services for browser. Parameters: Parameter Type Default Value Description services this IServiceCollection - The services. option ReduxDevToolOption? null The middleware options. isScoped bool false If true, registers with AddScoped, otherwise AddSingleton. Returns: The service collection. AddRemoteReduxDevToolMiddleware Extension Register the middleware to services for via remote connection. Parameters: Parameter Type Default Value Description services this IServiceCollection - The services. isScoped bool false If true, registers with AddScoped, otherwise AddSingleton. chromiumDevToolOption ReduxDevToolOption? null The middleware options. hostName string \"0.0.0.0\" The proxy server hostname. port ushort 8000 The proxy server port. secure bool false Uses HTTPS if true, otherwise HTTP. Returns: The service collection. ReduxDevToolOption Property Type Default Value Description Name string \"Memento Developer Tool\" The name displayed in the developer tool. MaximumHistoryLength uint 50 The maximum number of history entries stored by the developer tool. Latency TimeSpan TimeSpan.FromMilliseconds(800) The latency for the developer tool. StackTraceEnabled bool true Indicates whether stack traces are enabled in the developer tool. StackTraceLinesLimit int 30 The limit of stack trace lines displayed in the developer tool. OpenDevTool bool false Indicates whether the developer tool should be opened by default."
  },
  "samples/Memento.Sample.Blazor/wwwroot/css/open-iconic/README.html": {
    "href": "samples/Memento.Sample.Blazor/wwwroot/css/open-iconic/README.html",
    "title": "Open Iconic v1.1.1 | Memento",
    "keywords": "Open Iconic v1.1.1 Open Iconic is the open source sibling of Iconic. It is a hyper-legible collection of 223 icons with a tiny footprint—ready to use with Bootstrap and Foundation. View the collection What's in Open Iconic? 223 icons designed to be legible down to 8 pixels Super-light SVG files - 61.8 for the entire set SVG sprite—the modern replacement for icon fonts Webfont (EOT, OTF, SVG, TTF, WOFF), PNG and WebP formats Webfont stylesheets (including versions for Bootstrap and Foundation) in CSS, LESS, SCSS and Stylus formats PNG and WebP raster images in 8px, 16px, 24px, 32px, 48px and 64px. Getting Started For code samples and everything else you need to get started with Open Iconic, check out our Icons and Reference sections. General Usage Using Open Iconic's SVGs We like SVGs and we think they're the way to display icons on the web. Since Open Iconic are just basic SVGs, we suggest you display them like you would any other image (don't forget the alt attribute). <img src=\"/open-iconic/svg/icon-name.svg\" alt=\"icon name\"> Using Open Iconic's SVG Sprite Open Iconic also comes in a SVG sprite which allows you to display all the icons in the set with a single request. It's like an icon font, without being a hack. Adding an icon from an SVG sprite is a little different than what you're used to, but it's still a piece of cake. Tip: To make your icons easily style able, we suggest adding a general class to the <svg> tag and a unique class name for each different icon in the <use> tag. <svg class=\"icon\"> <use xlink:href=\"open-iconic.svg#account-login\" class=\"icon-account-login\"></use> </svg> Sizing icons only needs basic CSS. All the icons are in a square format, so just set the <svg> tag with equal width and height dimensions. .icon { width: 16px; height: 16px; } Coloring icons is even easier. All you need to do is set the fill rule on the <use> tag. .icon-account-login { fill: #f00; } To learn more about SVG Sprites, read Chris Coyier's guide. Using Open Iconic's Icon Font... …with Bootstrap You can find our Bootstrap stylesheets in font/css/open-iconic-bootstrap.{css, less, scss, styl} <link href=\"/open-iconic/font/css/open-iconic-bootstrap.css\" rel=\"stylesheet\"> <span class=\"oi oi-icon-name\" title=\"icon name\" aria-hidden=\"true\"></span> …with Foundation You can find our Foundation stylesheets in font/css/open-iconic-foundation.{css, less, scss, styl} <link href=\"/open-iconic/font/css/open-iconic-foundation.css\" rel=\"stylesheet\"> <span class=\"fi-icon-name\" title=\"icon name\" aria-hidden=\"true\"></span> …on its own You can find our default stylesheets in font/css/open-iconic.{css, less, scss, styl} <link href=\"/open-iconic/font/css/open-iconic.css\" rel=\"stylesheet\"> <span class=\"oi\" data-glyph=\"icon-name\" title=\"icon name\" aria-hidden=\"true\"></span> License Icons All code (including SVG markup) is under the MIT License. Fonts All fonts are under the SIL Licensed."
  }
}